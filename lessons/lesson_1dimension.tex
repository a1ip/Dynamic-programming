\section{Числа Фибоначчи}

Ход выполнения рекурсивного алгоритма для вычисления чисел Фибоначчи
можно проиллюстрировать его рекурсивным деревом: TODO F(6)

Обратите внимание, что число $F(4)$ вычисляется на обеих сторонах этого дерева, а число
$F(2)$ вычисляется в этом небольшом примере целых пять раз.

Время работы этого алгоритма пропорционально $O(F(N))$, так как результат накапливается
сложением единиц, которые возвращает функция при $n=1$. Так как числа Фибоначчи растут почти
как $2^n$, то временная сложность этого алгоритма --- $O(2^n)$.

В действительности мы можем решить эту задачу намного эффективнее. Для этого мы явно сохраняем
результаты вычисления каждого числа Фибоначчи в таблице. Теперь, прежде чем вычислять
значение, мы сначала проверяем его наличие в таблице, избегая повторных вычислений.

\begin{lstlisting}
const int N = 45;
int f[N + 1];

int fib(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (f[n] > 0)
        return f[n];
    f[n] = fib(n-1) + fib(n-2);
    return f[n];
}
\end{lstlisting}

TODO: дерево вызовов

Теперь при вызове $F(6)$ сколько либо значимого ветвления рекурсивного дерева не будет,
поскольку все вычисления будут выполняться в левой ветви дерева. Вызовы в правой ветви
находят нужные значения в таблице и немедленно возвращают управление.

Такой подход называется решением сверху вниз: решение начинается с исходной задачи, которая 
рекурсивно разбивается на подзадачи.

TODO: временная сложность

Ту же самую таблицу можно заполнить с помощью обычного цикла и без рекурсии.
Тогда работа алгоритма станет ещё эффективнее, так как не будет теряться время на
лишние рекурсивные вызовы.
Такой вариант решения называется снизу вверх --- сначала мы решаем все мелкие подзадачи,
а потом переходим к более крупным, объединяя в них уже известные мелкие подзадачи.

\begin{lstlisting}
const int N = 45;
int f[N + 1];

void init_fib()
{
    f[0] = 0;
    f[1] = 1;
    for (int i = 2 ; i <= N ; ++i)
        f[i] = f[i-1] + f[i-2];
}

int fib(int n)
{
    return f[n];
}
\end{lstlisting}

Мы начинаем вычисление всех $N$ чисел Фибоначчи с наименьшего числа. Поэтому когда нам
нужно вычислить $F_i$, в таблице уже есть требуемые для этого $F_{i-1}$ и $F_{i-2}$.
Временная сложность этого алгоритма --- $O(n)$, так как для вычисления каждой ячейки
массива нужно выполнить всего одно сложения и одно присваивание.

Если же нужно вычислить только одно (последнее) значение из таблицы, то можно полностью
от неё избавиться:

\begin{lstlisting}
int fib(int n)
{
    int a = 0, b = 1;
    if (n == 0) return 0;
    for (int i = 2 ; i <= n ; ++i)
    {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}
\end{lstlisting}

Временная сложность этого алгоритма остается прежней, но требования к памяти снижаются
до нескольких переменных.

\section{Ход конём}

Шахматная ассоциация решила оснастить всех своих сотрудников такими
телефонными номерами, которые бы набирались на кнопочном телефоне
ходом коня. Например, ходом коня набирается телефон \texttt{340-4927}. При
этом телефонный номер не может начинаться ни с цифры $0$, ни с цифры $8$.

Клавиатура телефона выглядит так:
{
\LARGE
\begin{tabular}{|c|c|c|}
\hline
7 & 8 & 9 \\
\hline
4 & 5 & 6 \\
\hline
1 & 2 & 3 \\
\hline
  & 0 &   \\
\hline
\end{tabular}
}

Напишите программу, определяющую количество телефонных номеров 
длины $N$, набираемых ходом коня.

Для решения этой задачи можно определить десять рекуррентностей $K_{i,n}$ ---
по одной на каждую кнопку. $k$-е члены каждой рекуррентной последовательности
будут равны количеству номеров телефона длины $k$, оканчивающихся на соответствующую цифру.

Среди номеров из одной цифры нет только номеров $8$ и $0$, так как они не могут
начинаться с этих цифр по условию. Тогда $K_{i,1} = 1$, если $i \neq 0$ и $i \neq 8$.

Допустим, очередная $k$-я цифра номера --- это $7$. Это значит, что предыдущей $k-1$ цифрой
была $6$ или $2$, так как конь мог сделать свой $k$-й шаг только из этих двух кнопок.
Следовательно, $K_{7,n} = K_{6,n-1} + K_{2,n-1}$. Аналогично можно рассмотреть все остальные
кнопки. Тогда мы получим следующие выражения для рекуррентностей при $n > 1$:

\begin{align*}
K_{0,n} &= K_{4,n-1} + K_{6,n-1} \\
K_{1,n} &= K_{6,n-1} + K_{8,n-1} \\
K_{2,n} &= K_{7,n-1} + K_{9,n-1} \\
K_{3,n} &= K_{4,n-1} + K_{8,n-1} \\
K_{4,n} &= K_{3,n-1} + K_{9,n-1} + K_{0,n-1} \\
K_{5,n} &= 0 \\
K_{6,n} &= K_{1,n-1} + K_{7,n-1} + K_{0,n-1} \\
K_{7,n} &= K_{2,n-1} + K_{6,n-1} \\
K_{8,n} &= K_{1,n-1} + K_{3,n-1} \\
K_{9,n} &= K_{2,n-1} + K_{4,n-1} \\
\end{align*}

В силу симметрии номеронабирателя, $K_{7,n} = K_{9,n}$, $K_{4,n} = K_{6,n}$, $K_{1,n} = K_{3,n}$.
Поэтому набор этих рекуррентностей можно несколько упростить.

Ответом на задачу будет $\sum_{i=0}^{n}K_{i,n}$ --- все номера, оканчивающиеся на каждую из цифр.

\section{Сообщение}

В сообщении, состоящем из одних русских букв и пробелов, каждую букву заменили
её порядковым номером в русском алфавите (А - 1, Б - 2, ..., Я - 33), а пробел
- нулем. Требуется по заданной последовательности цифр найти количество
исходных сообщений, из которых она могла получиться.



\section{Количество способов решения задачи (задача о кузнечике)}

Рассмотрим следующую задачу. На числовой прямой сидит кузнечик, который может прыгать вправо на одну или на две единицы. Первоначально кузнечик находится в точке с координатой 0. Определите количество различных маршрутов кузнечика, приводящих его в точку с координатой n.

\section{Наилучшее решение задачи (задача о кузнечике со стоимостями)}

Пусть кузнечик прыгает на одну или две точки вперед, а за прыжок в каждую точку необходимо заплатить определенную стоимость. Стоимость прыжка в точку $i$ задается значением $Price_i$. Необходимо найти маршрут с минимальной стоимостью из точки $0$ в точку $n$.

\section{Наибольшая возрастающая подпоследовательность}

Пример исходной последовательности: $\S=\{2,4,3,5,1,7,6,9,8\}$. Самая длинная возрастающая
подпоследовательность последовательности $S$ состоит из пяти элементов: $\{2,3,5,6,8\}$.

Как определить какие элементы последовательности нужно пропустить? Чтобы применить динамическое
программирование, нужно создать рекуррентное соотношение, которое вычисляет длину
наибольшей возрастающей подпоследовательнсти.

Какая информация о первых $n-1$ элементах последовательности $S$ помогла бы найти решение для
всей последовательности? Как минимум, нам нужно знать длину наибольшей возрастающей 
подпоследовательности для $s_1 \ldots s_{n-1}$. Но длины недостаточно для получения полного
решения. Пусть найденная длина решения для $s_1 \ldots s_{n-1}$ равна $5$. Если $s_n = 9$,
то увеличится ли длина наибольшей возрастающей подпоследовательности для множества
$s_1 \ldots s_n$?

Поэтому определим $l_i$, как количество чисел самой длинной возрастающей последовательности,
заканчивающейся на $s_i$. Тогда самая длинная возрастающая подпоследовательность, содержащая
$s_n$, получается в результате добавления этого числа в конец самой длинной возрастающей
последовательности слева от $s_n$ и оканчивающейся числом, меньшим, чем $s_n$. Длина $l_i$
вычисляется с помощью следующего рекуррентного соотношения:

\begin{align*}
l_0 &= 0 \\
l_i &= \max_{0<j<i}(l_j + 1), \quad \text{ где $s_j < s_i$}
\end{align*}

Эти значения определяют количество элементов в самой длинной возрастающей последовательности,
заканчивающейся определенным числом. Количество элементов в наибольшей возрастающей
подпоследовательности полной последовательности можно выразить формулой $\max_{1\le i\le n}l_i$,
так как лучшая последовательность должна заканчиваться на один из элементов $S$.

Какую вспомогательную информацию нам следует сохранить, чтобы восстановить саму
последовательность, а не только её длину? Для каждого элемента $s_i$ сохраняется его
предшественник, а именно индекс $p_i$ элемента, непосредственно предшествующего $s_i$
в наибольшей возрастающей подпоследовательности, оканчивающейся на $s_i$. Так как все
эти указатели направлены влево, то самую длинную последовательность можно восстановить,
начав с её последнего значения и следуя указателям на другие её члены.

Какова временная сложность этого алгоритма? Если каждое из $n$ значений $l_i$ вычисляется
путём сравнения $s_i$ с $i-1$ значениями слева от него, то общее время этого анализа
будет равно $O(n^2)$.

\begin{tabular}{l|c|c|c|c|c|c|c|c|c}
Последовательность $s_i$ & 2 & 4 & 3 & 5 & 1 & 7 & 6 & 9 & 8 \\
\hline
Длина $l_i$              & 1 & 2 & 3 & 3 & 1 & 4 & 4 & 5 & 5 \\
\hline
Предшественник $p_i$     &   & 1 & 1 & 2 &   & 4 & 4 & 6 & 6 \\
\end{tabular}

