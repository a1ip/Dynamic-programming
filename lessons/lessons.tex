\documentclass[14pt,openany]{book}

\include{preamble}

\begin{document}

\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\clearpage

\part{Занятия}

\chapter{Рекуррентные соотношения}

\section{Ханойская башня}

Ханойская башня --- несколько дисков, нанизанных в порядке уменьшения размеров на один из
трех колышков. Задача состоит в том, чтобы переместить всю башню на один из других колышков,
перенося каждый раз только один диск и не помещая больший диск на меньший.
Какое количество перемещений дисков необходимо и достаточно для выполнения задачи?

\textsc{Обозначай и властвуй}: путь $T_n$ --- минимальное число перекладываний, необходимых
для перемещения башни размером $n$ с одного колышка на другой. Очевидно, что $T_1=1$, а $T_2=3$.
Специальный крайний случай --- $T_0=0$, ведь для перемещения башни без дисков вообще ничего делать
не нужно.

Как переместить всю бащню? Эксперементы с тремя дисками показывают, что для такой башни нужно 
сначала переместить два верхних диска на один колышек, потом нижний диск на другой. И уже 
после этого два верхних диска снова перемещаются на самый большой. В общем случае мы сначала
перемещаем $n-1$ меньших дисков на любой из колышков (что требует $T_{n-1}$ перекладываний),
затем перемещаем самый большой диск (одно перекладывание) и, наконец, помещаем $n-1$
меньших дисков обратно на самый большой диск (ещё $T_{n-1}$ перекладываний). 

Таким образом, $n$ дисков (при $n>0$) можно переместить самое большее за $2T_{n-1}+1$
перекладываний. Меньше перекладываний сделать не получится, потому что когда мы хотим
переместить самый большой диск, $n-1$ меньших дисков должны находиться на одном колышке,
а для этого потребуется не меньше $T_{n-1}$ перекладываний.
Несколько раз перекладывать большой диск смысла нет. После его перемещения меньшие диски нужно
переместить на него обратно за $T_{n-1}$ перекладываний. Следовательно,

\begin{equation}
\label{formula-hanoi-rec}
\begin{array}{ll}
T_0 = 0, \\
T_n = 2T_{n-1} + 1 & \text{при } n > 0 \\
\end{array}
\end{equation}

Совокупность равенств типа~\ref{formula-hanoi-rec} называется \emph{рекуррентностью}. Она задается
начальным значением и зависимостью общего члена от предыдущих.

Рекуррентность вида~\ref{formula-hanoi-rec} позволяет вычислять $T_n$ для любого $n$, какое мы пожелаем. Но в действительности
никто не захочет пользоваться для вычисления рекуррентностью, когда $n$ велико --- это займёт
слишком много времени. Рекуррентность даёт только косвенную, локальную информацию.
Решение рекуррентного соотношения --- это запись $T_n$ в простой и компактной
<<замкнутой форме>>. Такая запись позволяет вычислить $T_n$ быстро даже при большом $n$.

Прибавим $1$ к обеим частям уравнения:

\begin{equation}
\begin{array}{ll}
T_0 + 1 = 1, \\
T_n + 1 = 2T_{n-1} + 2 & \text{при } n > 0 \\
\end{array}
\end{equation}

Теперь, если положить $U_n = T_n + 1$, то получим 

\begin{equation}
\begin{array}{ll}
U_0 = 1, \\
U_n = 2U_{n-1} & \text{при } n > 0 \\
\end{array}
\end{equation}

Очевидно, что $U_n = 2^n$. Тогда $T_n = 2^n - 1$.


\subsection{Метод математической индукции}

Значения $T_n$ можно вычислять для разных $n$. Получится $T_0=0, T_1=1, T_2=3, T_3=7, T_4=15$.
Можно предположить, что $T_n=2^n-1$. Проверим это с помощью математической индукции.

База индукции тривиальна --- $T_0 = 0$. Индуктивный переход: если $T_{n-1}=2^{n-1}-1$, то
$T_n = 2T_{n-1}+1 = 2(2^{n-1}-1)+1 = 2^n - 1$. Следовательно, предположение было справедливо.

\section{Как решать задачи с рекуррентностями}

\begin{itemize}
\item Рассмотреть крайние случаи. Они помогают вникнуть в задачу и проверить
      следующие этапы.
\item Найти математическое выражение для интересующей величины ---
      рекуррентность, которая позволяет при заданном $n$ вычислить результат.
\item Найти и доказать замкнутое выражение для рекуррентности.
\end{itemize}

\section{Задача о разрезании пиццы}

Сколько кусков пиццы можно получить, делая $n$ прямолинейных разрезов ножом?
Или же, каково максимальное число $L_n$ областей, на которые плоскость делится
$n$ прямыми?

Рассмотрим крайние случаи. Плоскость без прямых --- это одна область, 
с одной прямой --- две области, а с двумя прямыми --- четыре области.
Может показаться, что $L_n = 2^n$, но в общем случае это не так.
При добавлении третьей прямой мы можем пересечь самое большее три области,
поэтому $L_3 = 7$.

Новая $n$-я прямая увеличивает число областей на $k$, когда рассекает $k$ старых
областей. А рассекает она $k$ старых областей, когда пересекает прежние прямые
в $k-1$ различных местах. Две прямые могут пересекаться не более чем в одной точке.
Поэтому новая прямая может пересекать $n-1$ старых прямых не более чем в $n-1$
различных точках. Если проводить прямую так, чтобы она не была параллельна ни одной
из уже имеющихся, она обязательно пересечет их все. При этом, надо выбирать прямую так,
чтобы она не проходила через уже имеющиеся пересечения. Поэтому искомое рекуррентное
соотношение имеет вид:

\begin{equation}
\label{formula-pizza-rec}
\begin{array}{ll}
L_0 = 1, \\
L_n = L_{n-1} + n & \text{при } n > 0 \\
\end{array}
\end{equation}

Теперь можно вычислить значения этого ряда: $1, 2, 4, 7, 11, 16, \ldots$. 
Но теперь довольно сложно угадать что за замкнутая форма стоит за ними.

\subsection{Разворачивание рекуррентности}

Развернем формулу~\ref{formula-pizza-rec}, подставляя в выражение последовательно её саму:

\begin{align*}
L_n &= L_{n-1} + n \\
    &= L_{n-2} + (n-1) + n \\
    &= L_{n-3} + (n-2) + (n-1) + n \\
    & \qquad\vdots \\
    &= L_0 + 1 + 2 + \cdots + (n-2) + (n-1) + n \\
    &= 1 + S_n, \text{ где $S_n$ --- сумма первых $n$ натуральных чисел}
\end{align*}

Последовательность $S_n$ начинается следующими числами: $1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, \ldots$.
Эти числа называются также \emph{треугольными числами}, поскольку $S_n$ представляет собой
число кеглей, расставленных треугольником в $n$ рядов.

\subsection{Сумма натуральных чисел}

Метод Гаусса --- складываем числа парами. Первое --- с последним, второе --- с предпоследним,
и так далее:

\begin{equation}
\begin{array}{cccccccccccccc}
  & S_n & = & 1 & + & 2 & + & 3 & + & \cdots & + & (n-1) & + & n \\
+ & S_n & = & n & + & (n-1) & + & (n-2) & + & \cdots & + & 2 & + & 1 \\
\hline
  & 2S_n & = & (n+1) & + & (n+1) & + & (n+1) & + & \cdots & + & (n+1) & + & (n+1)
\end{array}
\end{equation}

Сумма каждой пары таких чисел равна $n+1$, поэтому $S_n = \frac{n(n+1)}{2}$ при $n \ge 0$.

Поэтому $L_n = \frac{n(n+1)}{2} + 1$ при $n \ge 0$.
Это выражение можно проверить с помощью математической индукции:

$$
L_n = L_{n-1} + n = \left(\frac{1}{2}(n-1)n+1 \right)+n = \frac{1}{2}n(n+1) + 1
$$

\section{Задачи}

\input{tasks01}

\section{Ответы на задачи}

\begin{enumerate}
\item Если новая $n$-я прямая пересекает прежние прямые в $k>0$ различных точках,
мы получаем $k-1$ новых конечных областей (в предположении, что ни одна из прежних прямых
не параллельна никакой другой) и $2$ новые бесконечные области. Следовательно, максимальное
число конечных областей равно $(n-2) + (n-3) + \cdots = S_{n-2} = (n-1)(n-2)/2 = L_n-2n$.

\item 233 способами

\item Пусть $a_n$ --— количество способов, которыми кузнечик может добраться до $n$-ой клетки. Тогда $a_1 = a_2 = 1$. Кроме того, в $n+1$-ую клетку кузнечик может попасть либо из $n$-ой клетки, либо перепрыгнув $n$-ую клетку. Поэтому $a_{n + 1} = a_{n - 1} + a_n$. Отсюда $a_n = F_n - 1$. 

\item $F_{n + 1}$.

\item По условию  $a_2 = a_1a_3, a_3 = a_2a_4, \ldots, a_{99} = a_{98}a_{100}$.
      Перемножив два соседних равенства, получим $a_ka_{k+3} = 1$,  то есть 
      $a_{k+3} = \frac{1}{a_k}$. Значит, $a_{k+6} = a_k$. 
      Следовательно, $a_1 = a_7 = \cdots = a_{97} = 7$,
      а $a_{100} = \frac{1}{a_{97}} = \frac{1}{7}$.

\item $a_n = 2^n + 1 (n \ge 0)$

\item \begin{enumerate}
    \item Обозначим через $а_n$ число способов подняться на лестницу из $n$ ступенек, соблюдая условия задачи. Очевидно,  $a_1 = 1,  a_2 = 2$.
    
   Пусть Петя запрыгивает на лестницу из $n > 2$  ступенек. Если первый прыжок был на две ступеньки, то ему осталось запрыгнуть на  $n – 2$  ступеньки, и число способов закончить подъем равно $a_{n–2}$. Если же первый прыжок был на одну ступеньку, то число способов закончить подъем равно $a_{n–1}$. Значит, $a_n = a_{n–1} + a_{n–2}$.

   Это равенство позволяет, зная $a_1$ и $a_2$, вычислять последовательно все $a_n$ (при этом будут получаться известные числа Фибоначчи):
$a_3 = 3,  a_4 = 5,  a_5 = 8,  a_6 = 13,  a_7 = 21,  a_8 = 34,  a_9 = 55,  a_{10} = 89$.

   \item Каждую из $9$ ступенек (кроме последней) Петя может либо перепрыгнуть, либо не перепрыгнуть независимо от того, на каких из верхних ступенек он останавливался. Поэтому количество способов спуститься по лестнице равно $2^9$.

 \end{enumerate}

\item Обозначим за $a_n$ количество слов длины $n$, состоящих только из букв <<а>> и <<б>> и не содержащих в записи двух букв <<б>> подряд. Таким образом, находим $a_1=2, a_2=3$. Покажем, что $a_n$ можно выразить через $a_{n-1}$ и $a_{n-2}$. Количество слов длины $n$, не содержащих в записи двух букв <<б>> подряд и начинающихся с буквы <<а>>, равно $a_{n-1}$, так как после первой буквы может следовать любое слово длины $n-1$, не содержащее двух <<б>> подряд. Пусть слово длины $n$ начинается с буквы <<б>>. Если в этом слове нет двух <<б>> подряд, то вторая буква --- <<а>>, а далее может следовать любое слово длины $n-2$, не содержащее двух <<б>> подряд. Таким образом, количество слов длины $n$, не содержащих в записи двух букв <<б>> подряд и начинающихся с буквы <<б>>, равно $a_{n-2}$. Тем самым, мы показали, что $a_n=a_{n-1}+a_{n-2}$. Теперь последовательно вычисляем $a_3=a_2+a_1=3+2=5$, $a_4=a_3+a_2=5+3=8$ и т.д., $a_{10}=a_9+a_8=144$. Заметим, что получающиеся числа an --- это хорошо известные числа Фибоначчи. 

\item Заметим, что  $a_{n+3} = a_{n+2} – a_{n+1} = –a_n$.  Значит,  $a_{n+6} = a_n$,  то есть члены последовательности повторяются с периодом $6$. Так как $100$ при делении на $6$ дает остаток $4$, то  $a_{100} = a_4 = –a_1$.

\item Докажем требуемое утверждение по индукции. База индукции очевидна. Последовательность $\{a_n\}$ монотонно возрастает, поэтому для любого натурального числа $m$ можно выбрать $n$ так, что 
$a_n \le m < a_{n+1}$. По предположению индукции число $m - a_n$ (если оно отлично от нуля) можно представить в виде суммы нескольких разных членов последовательности $\{a_n\}$. При этом 
$m - a_n < a_{n + 1} - a_n = a_{n - 1}$. Значит, в этом разложении не присутствует даже 
$a_{n - 1}$, и, тем более, не присутствует $a_n$. 

\item 
  \begin{enumerate}
    \item $a_n = 3^n - 2^n$
    \item $a_n = 1$
    \item $a_n = F_{n+1}$
    \item $a_n = n + 1$
    \item $a_n = \frac{1}{2\sqrt{2}}\left(\left(1+\sqrt{2}\right)^n - \left(1-\sqrt{2}\right)^n\right)$
  \end{enumerate}

\item Если по кругу стоят числа $1, 2, \ldots, 2n$, то вначале вычеркиваются все четные числа. Оставшиеся числа $1, 3, 5, \ldots, 2n - 1$ снова подвергаются процедуре вычеркивания. $k$-ое число в этом списке имеет вид $2k - 1$. После того, как из этого списка будут вычеркнуты все числа кроме одного, останется число с номером $J(n)$, которое равно $2J(n) - 1$. 

\item $\frac{1}{5}(3^n-(-2)^n)$

\item Ясно, что после четного числа прыжков лягушка может находиться только в вершинах $A$, $C$ или $E$. Обозначим через $a_k$, $c_k$, $e_k$ число путей длины $2k$, ведущих из $A$ в $A$, $C$ и $E$ соответственно. В силу симметрии  $c_k = e_k$.  Легко видеть, что выполняются равенства
      $c_{k+1} = a_k + 3c_k$, $a_{k+1} = 2a_k + 2c_k$.
   Отсюда
      $c_{k+2} = a_{k+1} + 3c_{k+1} = 2a_k + 2c_k + 3c_{k+1} = 2(c_{k+1} – 3c_k) + 2c_k + 3c_{k+1} = 5c_{k+1} – 4c_k$.

   Из начальных условий $c_0 = 0,  c_1 = 1$,   находим $c_k = \frac{4^k - 1}{3}$ (это нетрудно доказать по индукции).
   Для второй подзадачи обозначим через $b_k$ число путей длины  $2k – 1$,  ведущих из $A$ в $B$. Тогда   $b_{k+1} = 3b_k$  (за два прыжка можно двумя способами вернуться из $B$ в $B$ и одним способом попасть из $B$ в $F$). Но $c_k = b_k$,   значит,
$c_{k+1} = 3c_k$  при  $k > 0$.  По-прежнему,  $c_1 = 1$,  следовательно, $c_k = 3^{k–1}$.

\item    Пусть $a_n$ --– число способов вернуться за $n$ прыжков в исходную вершину, а $b_n$ --– попасть за $n$ прыжков в соседнюю вершину.
Легко видеть, что   $a_{n+1} = 2b_n$,  $b_{n+1} = a_n + b_n$.   Отсюда нетрудно вывести, что   $b_{n+2} = b_{n+1} + 2b_n$,  $a_{n+2} = a_{n+1} + 2a_n$.
   Из начальных условий $a_0 = 1$, $a_1 = 0$,   получаем $a_n = \frac{2^n + 2(-1)^n}{3}$ (это нетрудно доказать по индукции).

\item TODO

\item   Обозначим через $M_n$ число всевозможных маршрутов длительностью $n$ минут. Каждый такой маршрут состоит ровно из $n$ участков (участок –-- это отрезок $AB$, $BA$ или кольцо $BB$). Пусть  $M_{n,A}$ – число таких маршрутов, оканчивающихся в $A$, а $M_{n,B}$ – число маршрутов с конечной точкой $B$.
  В точку $B$ за минуту можно попасть как из точки $A$, так и из точки $B$, поэтому  $M_{n,B} = M_{n–1}$.
  В точку $A$ за минуту можно попасть только из точки $B$, поэтому  $M_{n,A} = M_{n–1,B} = M_{n–2} = M_{n–2,A} + M_{n–2,B} = M_{n–2,A} + M_{n–3} = M_{n–2,A} + M_{n–1,A}$. 
  Дополнительно заметим, что  $M_{1,A} = 0$, $M_{2,A} = 1$.  Таким образом, числа $M_{n,A}$ образуют последовательность  $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \ldots$.
  Число $M_{10,A}$ равно $34$ --– девятому числу Фибоначчи.


\end{enumerate}

% \chapter{Ещё рекуррентные соотношения}

\chapter{Вычисление рекуррентностей на компьютере}

\section{Числа Фибоначчи}

Числа Фибоначчи определяются следующим рекуррентным соотношением:
\begin{align*}
F_0 &= 0, \\
F_1 &= 1, \\
F_n &= F_{n-1} + F_{n-2}, \text{ для $n>0$}
\end{align*}

Классическое приложение чисел Фибоначчи --- это определение размера популяции кроликов.
Если кролики становятся способными к размножению через месяц и каждая пара взрослых кроликов
производит на свет пару крольчат раз в месяц, то сколько пар кроликов будет в наличии
через $n$ месяцев.

\begin{task}
Написать программу, выводящую первые $n$ чисел Фибоначчи.
\end{task}

\begin{task}
Написать программу для разложения натурального числа на числа Фибоначчи.
\end{task}

\begin{task}
Начиная с какого числа Фибоначчи переполняются стандартные типы \texttt{int} и \texttt{long long}?.
\end{task}

\section{Домино}

\subsection{Покрытие прямоугольника $2\times n$}

Как велико число $T_n$ способов покрытия $2\times n$-прямоугольника костяшками домино размера
$2\times 1$? Будем считать, что все костяшки идентичны, следовательно имеет значение только
ориентация костяшки --- вертикальная или горизонтальная: мы можем представлять себе, что
работаем с плитками в форме домино. Например, существует $3$ покрытия $2\times 3$-прямоугольника,
а именно, |||, |= и =|, так что $T_3 = 3$. Для $n=1$ существует одно покрытие |. Для $n=2$
--- два покрытия: || и =. Для $n=0$ покрытие только одно, ведь есть только один
способ не класть ни одной костяшки.

Для $n=4$ имеется две возможности расположения плиток на левом конце прямоугольника
--- можно положить там либо одну плитку вертикально, либо две горизонтально. Если мы выберем
вертикальную плитку, то получим частичное решение |xxx и оставшийся $2\times 3$ прямоугольник
можно покрыть плитками $T_3$ способами. Если же выбрать две горизонтальные плитки, то
частичное решение =xx можно завершить $T_2$ способами. Таким образом, $T_4=T_3+T_2=5$.
Вот эти пять покрытий: ||||, ||=, |=|, =||, ==.

Рассуждения для $n=4$ легко обобщить для любого значения $n \ge 2$: $T_n = T_{n-1} + T_{n-2}$.
Таким образом, получается такое же рекуррентное соотношение, как и для чисел Фибоначчи,
только начальные значения другие. Однако это --- последовательные члены ряда Фибоначчи
$F_1$ и $F_2$, так что последовательность $T$ совпадает с последовательностью Фибоначчи,
сдвинутой на одну позицию: $T_n = F_{n+1} \text{ при $n \ge 0$}$.

\subsection{Покрытие прямоугольника $3\times n$}

Сколько существует способов покрыть костяшками домино $3 \times n$-прямоугольник
(обозначим это число $U_n$)? Пустое покрытие $U_0 = 1$. Для $n=1$ не существует допустимых
покрытий, поскольку одна $2\times 1$-плитка не заполняет $3 \times 1$-прямоугольник,
а для двух нет места.

Следующий случай, $n=2$, легко анализируется вручную: имеется три покрытия ${||}\atop{-}$,
${-}\atop{||}$ и $\equiv$, так что $U_2 = 3$. Для $n=3$ нет покрытий, так как его
площадь нечётна и поэтому ее не получится собрать из костяшек чётной площади.

Каждое непустое покрытие начинается с $\equiv$, L или Г. Но в последних двух случаях
не получится составить рекуррентность для $U_n$, так как правый край у них неровный.
Поэтому можно ввести дополнительную рекуррентность для покрытия. $V_n$  --- число
способов замостить $3\times n$-прямоугольник, оставив левый нижний угол пустым.
Аналогично $\Lambda_n$ --- число
способов замостить $3\times n$-прямоугольник, оставив левый верхний угол пустым.

Входящие в $V_n$ и $\Lambda_n$ покрытия могут начинаться двумя способами: с одной вертикальной
костяшки, которая выравнивает уже заполненный край и с трех костяшек, одна из которых сдвинута вправо.
Тогда,

\begin{align*}
U_0 &= 1 \\
U_1 &= 0 \\
U_n &= U_{n-2} + V_{n-1} + \Lambda_{n-1} \quad & \text{ для $n>1$}\\
V_0 &= 0 \\
V_1 &= 1 \\
V_n &= U_{n-1} + V_{n-2} & \text{ для $n>1$}\\
\Lambda_0 &= 0 \\
\Lambda_1 &= 1 \\
\Lambda_n &= U_{n-1} + \Lambda_{n-2} & \text{ для $n>1$}\\
\end{align*}

Очевидно, что $V_n = \Lambda_n$. Тогда рекуррентное соотношение можно упростить:

\begin{align*}
U_0 &= 1 \\
U_1 &= 0 \\
U_n &= U_{n-2} + 2V_{n-1} \quad & \text{ для $n>1$}\\
V_0 &= 0 \\
V_1 &= 1 \\
V_n &= U_{n-1} + V_{n-2} & \text{ для $n>1$}\\
\end{align*}

\begin{task}
Написать программу, для нахождения числа покрытий $3\times n$-прямоугольника костяшками домино.
\end{task}

\section{Размен}

Сколько существует способов заплатить $50$ центов, если есть монеты по $1$, $5$, $10$, $25$ и $50$ центов.

Используем несколько последовательностей. $P_n$ --- число способов заплатить сумму в $n$ центов
с помощью только одноцентовых монет. Очевидно, что $P_n = 1$ для всех $n>0$. 

Пусть $N_n$ --- число способов заплатить $n$ центов с помощью монет в $5$ и $1$ цент.
Чтобы заплатить эту сумму, нужно или взять одну монету в $5$ центов и выбрать остальное
$N_{n-5}$ способами, либо использовать только одноцентовые монеты и набрать сумму $P_n$
способами.

Аналогичные рассуждения можно провести для остальных монет (ряды $D_n$, $Q_n$, $C_n$). 
Тогда получится следующая рекуррентность
(все выражения для $n \ge 0$):

\begin{align*}
P_n &= 1 \\
N_n &= N_{n-5} + P_n \\
D_n &= D_{n-10} + N_n \\
Q_n &= Q_{n-25} + D_n \\
C_n &= C_{n-50} + Q_n \\
\end{align*}

Ответом на задачу будет $C_n$. Найти его можно построив таблицу:

$$
\begin{array}{c|cccccccccccc}
n   & 0 & 5 & 10 & 15 & 20 & 25 & 30 & 35 & 40 & 45 & 50 \\
\hline
P_n & 1 & 1 & 1  & 1  & 1  & 1  & 1  & 1  & 1  & 1  & 1  \\
N_n & 1 & 2 & 3  & 4  & 5  & 6  & 7  & 8  & 9  & 10 & 11 \\
D_n & 1 & 2 & 4  & 6  & 9  & 12 & 16 &    & 25 &    & 36 \\
Q_n & 1 &   &    &    &    & 13 &    &    &    &    & 49 \\
C_n & 1 &   &    &    &    &    &    &    &    &    & 50 \\
\end{array}
$$

Пустые клетки в таблице могли бы содержать значения, но они не используются при вычислении
$C_{50}$.

\section{Биномиальные коэффициенты}

Символ $\binom{n}{k}$ --- это биномиальный коэффициент. Другое обозначение --- $C_n^k$.
Читается он как <<выбор $k$ из $n$>> или <<$C$ из $n$ по $k$>>. Это число способов выбора
$k$-элементного подмножества из $n$-элементного множества. Например, два элемента
из множества $\{1,2,3,4\}$ можно выбрать шестью способами: 
$\{1,2\}, \{1,3\}, \{1,4\}, \{2,3\}, \{2,4\}, \{3,4\}$, так что $\binom{4}{2}=6$.

Чтобы найти выражение $\binom{n}{k}$, установим соотношение для числа $k$-элементных
последовательностей, выбранных из $n$-элементного множества, в которых учитывается порядок
элементов. Существует $n$ вариантов выбора первого элемента, $n-1$ --- второго элемента
и так далее до $n-k+1$ вариантов выбора $k$ элемента, что дает $n(n-1)\ldots(n-k+1)$
вариантов выбора.

Поскольку каждое $k$-элементное подмножество может быть упорядочено $k!$ различными способами,
найденное число последовательностей учитывает каждое подмножество $k!$ раз. Поэтому чтобы
получить число подмножеств, поделим число перестановок на $k!$:
$$\binom{n}{k} = \frac{n(n-1)\ldots(n-k+1)}{k(k-1)\ldots(1)}$$.

Таблица с биномиальными коэффициентами называется треугольником Паскаля:

$$
 \begin{array}{ccccccccccc}
 &&&&& 1 \\
 &&&& 1 && 1 \\
 &&& 1 && 2 && 1 \\
 && 1 && 3 && 3 && 1 \\
 & 1 && 4 && 6 && 4 && 1 \\
 1 && 5 && 10 && 10 && 5 && 1
 \end{array}
$$

$$
 \begin{array}{ccccccc}
 n & \binom{n}{0} & \binom{n}{1} & \binom{n}{2} & \binom{n}{3} & \binom{n}{4} & \binom{n}{5} \\
 0 & 1 \\
 1 & 1 & 1 \\
 2 &  1 & 2 & 1 \\
 3 & 1 & 3 & 3 & 1 \\
 4 & 1 & 4 & 6 & 4 & 1 \\
 5 & 1 & 5 & 10 & 10 & 5 & 1
 \end{array}
$$

Пустые места в таблице означают $0$ из-за нуля в числителе.

\begin{task}
Напишите программу, рисующую треугольника Паскаля до $n=24$ включительно.
\end{task}

Каждый ряд в треугольнике Паскаля симметричен, потому что $\binom{n}{k}=\binom{n}{n-k}$.
Комбинаторный смысл: определяя $k$ предметов, мы автоматически определяем оставшиеся $n-k$.

Правило внесения/вынесения:
$$\binom{n}{k} = \frac{n}{k}\binom{n-1}{k-1}$$

Формула сложения: каждое число в треугольнике Паскаля есть сумма двух чисел предыдущего ряда ---
того, что непосредственно над ним, и того, что сверху слева от него:
\begin{equation}
\label{formula-binom-rec}
\binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}
\end{equation}

Эту формулу можно обосновать с помощью исходного определения:
\begin{align*}
  \binom{n-1}{k} + \binom{n-1}{k-1} 
  &= \frac{(n-1)(n-2)\ldots(n-k)}{k(k-1)\ldots(1)} 
     + \frac{(n-1)(n-2)\ldots(n-k+1)}{(k-1)(k-2)\ldots(1)}  \\
  &= (n-k)\frac{(n-1)(n-2)\ldots(n-k+1)}{k(k-1)\ldots(1)} 
     + k\frac{(n-1)(n-2)\ldots(n-k+1)}{k(k-1)\ldots(1)} = \\
  &= (n-k+k)\frac{(n-1)(n-2)\ldots(n-k+1)}{k(k-1)\ldots(1)} \\
  &= \frac{n(n-1)(n-2)\ldots(n-k+1)}{k(k-1)\ldots(1)} = \binom{n}{k}
\end{align*}

Как обосновать формулу сложения? Предположим, у нас $n$ яиц, среди которых
одно тухлое. Есть $\binom{n}{k}$ способов выбрать $k$ яиц. В $\binom{n-1}{k}$
случаях все они будут свежие, а в $\binom{n-1}{k-1}$ случаях среди них будет
одно тухлое (здесь мы выбираем $k-1$ свежее яйцо и добавляем к ним тухлое).

Формула сложения --- это рекуррентность для чисел из треугольника Паскаля.

\begin{task}
Напишите программу, рисующую треугольника Паскаля до $n=24$ включительно,
используя формулу сложения.
\end{task}

Своим названием биномиальные коэффициенты обязаны \emph{биномиальной теореме}, которая
имеет дело со степенями бинома $x+y$. Вот простейшие случаи этой теоремы:
\begin{align*}
(x+y)^0 &= 1x^0y^0 \\
(x+y)^1 &= 1x^1y^0 + 1x^0y^1 \\
(x+y)^2 &= 1x^2y^0 + 2x^1y^1 + 1x^0y^2 \\
(x+y)^3 &= 1x^3y^0 + 3x^2y^1 + 3x^1y^2 + 1x^0y^3
\end{align*}

Нетрудно понять, почему эти коэффициенты совпадают с числами треугольника Паскаля.
Когда мы раскрываем скобки произведения сомножителей $(x+y)$,
каждый его член сам является произведением $n$ сомножителей $x$ и $y$.
Число таких членом с $k$ сомножителями $x$ и $n-k$ сомножителями $y$ после приведения
подобных членов становится коэффициентом при $x^ky^{n-k}$. А это равно числу
способов выбора $k$ из $n$ двучленов, из которых в произведение войдёт $x$,
т.е. это $\binom{n}{k}$.

Биномиальная теорема:
\begin{equation}
\label{formula-binom}
(x+y)^n = \sum_{k=0}^{n}\binom{n}{k}x^ky^{n-k}
\end{equation}

Если подставить в формулу~\ref{formula-binom} $x=1$ и $y=1$, то получится
\begin{equation}
2^n = \binom{n}{0} + \binom{n}{1} + \binom{n}{2} + \cdots + \binom{n}{n-1} + \binom{n}{n}
\end{equation}

То есть сумма ряда $n$-го ряда треугольника Паскаля равна $2^n$.

\section{Задачи}

\input{tasks02}

\section{Ответы на задачи}

\begin{enumerate}
\item Подставим в производящую функцию $z^4$ вместо | и z вместо -. Получим функцию $1/(1-z^4-z^2)$.
Это похоже на производящую функцию для $T$, однако $z$ заменено на $z^2$. Следовательно, 
ответом будет $0$ для нечетных $m$ и $F_{m/2+1}$ --- для четных.

\item Это задача размена с номиналами монет $10$ и $20$, поэтому $G(z)=(1/(1-z^{10})(1-z^{20})$.

\item Обозначим искомое число $a_n$, а через $b_n$ обозначим разбиение колонны с выемкой размера
      $2 \times 2 \times 1$ вверху. Рассматривая различные варианты расположения видимых сверху
      кирпичей, получим
$$
\begin{array}{ll}
a_n = 2a_{n-1} + 4b_{n-1} + a_{n-2} + [n=0]; \\
b_n = a_{n-1} + b_{n-1}.
\end{array}
$$
      Следовательно, производящие функции удовлетворяют уравнениям $A = 2zA+4zB+z^2A+1$ и
      $B = zA + zB$. Откуда находим $$A(z) = \frac{1-z}{(1+z)(1-4z+z^2)}$$
      $$a_n = \frac{1}{6}(2+\sqrt{3})^{n+1} + \frac{1}{6}(2-\sqrt{3})^{n+1} + \frac{1}{3}(-1)^n$$

\item Пусть $a_n$ --- число цепочек ДНК, которые не заканчиваются на $c$ или $e$, а $b_n$ --- число
      цепочек, заканчивающихся этими символами. Тогда
      $$
      \begin{array}{ll}
      a_n = 3a_{n-1}+2b_{n-1}+[n=0], & b_n = 2a_{n-1} + b_{n-1}, \\
      A(z) = 3zA(z) + 2zB(z) + 1,    & B(z) = 2zA(z) + zB(z), \\
      A(z) = \frac{1-z}{1-4z-z^2},   & B(z) = \frac{2z}{1-4z-z^2}. \\
      \end{array}
      $$
      Общее число цепочек равно $[z^n](1+z)/(1-4z-z^2) = F_{3n+2}$.

\item TODO

\item TODO

\item TODO

\item TODO

\end{enumerate}

\chapter{Динамическое программирование}

Динамическое программирование --- это технология для эффективной реализации рекурсивных алгоритмов
посредством сохранения промежуточных результатов. Секрет её применения заключается
в определении, выдаёт ли простой рекурсивный алгоритм одинаковые результаты для одинаковых
подзадач. Если выдаёт, то вместо повторения вычислений ответ каждой подзадачи можно
сохранять в таблице для использования в дальнейшем, что даёт возможность получить эффективный
алгоритм. Начинаем разработку с определения и отладки рекурсивного алгоритма. Только добившись
правильной работы нашего рекурсивного алгоритма, мы переходим к поиску мер по ускорению
его работы, сохраняя результаты в памяти.

Многократное вычисление некоего значения безвредно само по себе, пока затраченное на это время
не оказывает заметного влияния на производительность. Экономия времени исполнения за счёт повышенного
расхода памяти в динамическом программировании лучше всего проявляется в при вычислении
рекуррентных соотношений, таких как числа Фибоначчи.

Сохранение результатов вычислений в таблице имеет смысл только если в алгоритме присутствуют
повторяющиеся вычисления. 

Решение задачи с помощью динамического программирования состоит из трех шагов:
\begin{enumerate}
\item Сформулировать решение в виде рекуррентного соотношения или рекурсивного алгоритма.
\item Показать, что количество разных значений параметра, принимаемых рекуррентностью,
      ограничено полиномиальной функцией.
\item Указать порядок вычисления рекуррентного соотношения, чтобы частичные результаты
      были доступными, когда они потребуются.
\end{enumerate}

\section{Множество решаемых задач}

\section{Граф зависимостей задач}

\section{Пример решения задачи}

\chapter{Задачи с одним параметром}

\section{Числа Фибоначчи}

Пример рекурсивного алгоритма для вычисления чисел Фибоначчи:

\begin{lstlisting}
int fib(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fib(n-1) + fib(n-2);
}
\end{lstlisting}

Ход выполнения этого рекурсивного алгоритма можно проиллюстрировать его рекурсивным
деревом: TODO F(6)

Обратите внимание, что число $F(4)$ вычисляется на обеих сторонах этого дерева, а число
$F(2)$ вычисляется в этом небольшом примере целых пять раз.

Время работы этого алгоритма пропорционально $O(F(N))$, так как результат накапливается
сложением единиц, которые возвращает функция при $n=1$. Так как числа Фибоначчи растут почти
как $2^n$, то временная сложность этого алгоритма --- $O(2^n)$.

В действительности мы можем решить эту задачу намного эффективнее. Для этого мы явно сохраняем
результаты вычисления каждого числа Фибоначчи в таблице. Теперь, прежде чем вычислять
значение, мы сначала проверяем его наличие в таблице, избегая повторных вычислений.

\begin{lstlisting}
const int N = 45;
int f[N + 1];

int fib(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (f[n] > 0)
        return f[n];
    f[n] = fib(n-1) + fib(n-2);
    return f[n];
}
\end{lstlisting}

TODO: дерево вызовов

Теперь при вызове $F(6)$ сколько либо значимого ветвления рекурсивного дерева не будет,
поскольку все вычисления будут выполняться в левой ветви дерева. Вызовы в правой ветви
находят нужные значения в таблице и немедленно возвращают управление.

Такой подход называется решением сверху вниз: решение начинается с исходной задачи, которая 
рекурсивно разбивается на подзадачи.

TODO: временная сложность

Ту же самую таблицу можно заполнить с помощью обычного цикла и без рекурсии.
Тогда работа алгоритма станет ещё эффективнее, так как не будет теряться время на
лишние рекурсивные вызовы.
Такой вариант решения называется снизу вверх --- сначала мы решаем все мелкие подзадачи,
а потом переходим к более крупным, объединяя в них уже известные мелкие подзадачи.

\begin{lstlisting}
const int N = 45;
int f[N + 1];

void init_fib()
{
    f[0] = 0;
    f[1] = 1;
    for (int i = 2 ; i <= N ; ++i)
        f[i] = f[i-1] + f[i-2];
}

int fib(int n)
{
    return f[n];
}
\end{lstlisting}

Мы начинаем вычисление всех $N$ чисел Фибоначчи с наименьшего числа. Поэтому когда нам
нужно вычислить $F_i$, в таблице уже есть требуемые для этого $F_{i-1}$ и $F_{i-2}$.
Временная сложность этого алгоритма --- $O(n)$, так как для вычисления каждой ячейки
массива нужно выполнить всего одно сложения и одно присваивание.

Если же нужно вычислить только одно (последнее) значение из таблицы, то можно полностью
от неё избавиться:

\begin{lstlisting}
int fib(int n)
{
    int a = 0, b = 1;
    if (n == 0) return 0;
    for (int i = 2 ; i <= n ; ++i)
    {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}
\end{lstlisting}

Временная сложность этого алгоритма остается прежней, но требования к памяти снижаются
до нескольких переменных.

\section{Упражнения}

\begin{enumerate}

\item Строка $S$ состоит из десятичных цифр. Её можно разбить на непустые последовательные
      подстроки $S_0, S_1, S_2, \ldots$. Каждая подстрока $S_i$ определяет число $a_i$. Из чисел
      $a_i$ образуется многочлен $a_0 + a_1\cdot x + a_2\cdot x^2 + a_3\cdot x^3 + \cdots$.
      
      Требуется разбить строку $S$ так, чтобы при заданном значении $x$ значение многочлена
      было минимальным.

\item Найти количество последовательностей заданной длины $n$ из нулей и единиц, таких что в них
      не встречается трёх единиц подряд.

\end{enumerate}

\chapter{Двумерное динамическое программирование}

\section{Биномиальные коэффициенты}

Биномиальные коэффициенты удобнее всего вычислять с помощью соотношения~\ref{formula-binom-rec}.
Заполняя клетки в таблице, содержащей треугольник Паскаля, сверху вниз, мы можем
использовать уже вычисленные значения, так как правая часть формулы ссылается только на
предыдущую строку.

$$
 \begin{array}{ccccccc}
 n & \binom{n}{0} & \binom{n}{1} & \binom{n}{2} & \binom{n}{3} & \binom{n}{4} & \binom{n}{5} \\
 0 & 1 \\
 1 & 1 & 1 \\
 2 &  1 & 2 & 1 \\
 3 & 1 & 3 & 3 & 1 \\
 4 & 1 & 4 & 6 & 4 & 1 \\
 5 & 1 & 5 & 10 & 10 & 5 & 1
 \end{array}
$$

\begin{lstlisting}
const int N = 20;
int c[N + 1][N + 1];

void fill_binom()
{
    c[0][0] = 1;
    for (int i = 1 ; i <= N ; ++i)
    {
        c[i][0] = 1;
        for (int j = 1 ; j <= i ; ++j)
            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
    }
}
\end{lstlisting}

\section{Упражнения}

\begin{enumerate}

\item Найти минимальное натуральное число с заданной суммов кубов цифр.

\item Натуральное число назовём <<плавным>>, если разность двух его соседних цифр не превосходит
      по модулю единицы. Определить количество $n$-значных <<плавных>> чисел.

\end{enumerate}

\chapter{Задачи на матрицах}

\section{Путь в матрице 1}

На плоскости из любой точки $(x, y)$ разрешается перемещаться в точку $(x+1,y)$ или $(x,y+1)$.
Сколькими способами можно добраться из начала координат $(0,0)$ в точку $(m,n)$?

Обозначим через $ways(x,y)$ количество путей, ведущих из начала координат в точку $(x,y)$.
Тогда справедливо рекуррентное соотношение
\begin{align*}
ways(0,0) &= 1 \\
ways(x,y) &= ways(x-1,y) + ways(x,y-1)
\end{align*}

В программе мы можем завести одноимённую таблицу $ways$ и заполнить её, получив интересующее
нас значение $ways[m][n]$. Задачу мы будем решать снизу вверх, чтобы избежать накладных
расходов, связанных с рекурсивными вызовами.

\begin{lstlisting}
int count(int m, int n)
{
    int ways[MAXM + 1][MAXN + 1];
    for (int x = 0 ; x <= m ; ++x)
    {
        for (int y = 0 ; y <= n ; ++y)
        {
            if (x > 0)
            {
                if (y > 0)
	            {
                    ways[x][y] = ways[x-1][y] + ways[x][y-1];
	            }
                else
                {
                    ways[x][y] = ways[x - 1][y];
                }
            }
            else
            {
                if (y > 0)
                {
                    ways[x][y] = ways[x][y - 1];
                }
                else
                {
                    ways[x][y] = 1;
                }
            }
        }
    }
    return ways[m][n];
}
\end{lstlisting}

В этой программе всегда заполняется только одна строка на основе данных из предыдущей.
Поэтому можно двумерный массив свести к одномерному:

\begin{lstlisting}
int count(int m, int n)
{
    int ways[MAXN + 1];
    for (int y = 0 ; y <= n ; ++y)
        ways[y] = 1;
    for (int x = 1 ; x <= m ; ++x)
        for (int y = 1 ; y <= n ; ++y)
       	    ways[y] += ways[y-1];
    return ways[m][n];
}
\end{lstlisting}

\section{Путь в матрице 2}

Рассмотрим шахматную доску в левом верхнем углу которой находится король. Король может перемещаться только вправо, вниз или по диагонали вправо-вниз на одну клетку. Необходимо определить количество различных маршрутов короля, приводящих его в правый нижний угол.

Теперь решим задачу о нахождении маршрута минимальной стоимости из левого верхнего угла в правый нижний, считая что для каждой клетке указана стоимость прохода через эту клетку.

Игры

\section{Игра <<Ферзя в угол>>}

Рассмотрим игру <<Ферзя в угол>> для двух игроков. В левом верхнем углу доски размером $n \times m$ 
находится ферзь, который может двигаться только вправо-вниз. Игроки по очереди двигают ферзя, то есть 
за один ход игрок может переместить ферзя либо по вертикали вниз, либо по горизонтали вправо, либо во 
диагонали вправо-вниз. Игрок, который не может сделать ход — проигрывает, иными словами, выигрывает 
игрок, который поставит ферзя в правый нижний угол. Необходимо определить, какой из игроков может 
выиграть в этой игре независимо от ходов другого игрока.


\chapter{Задачи на отрезках}

Задачи на отрезках могут определяться на некоторой строке символов, последовательности чисел
и т.п. Решение полной задачи определяется через решение задач для подотрезков.

\section{Палиндром}

Палиндром --- это симметричная строка, то есть она одинаково читается как слева направо,
так и справа налево. Требуется по заданной строке определить минимальное количество
символов,
которые необходимо вставить в строку для преобразования её в палиндром.

Входные данные --- строка $S$ длиной $n$ символов ($3 \le n \le 5000$).
Выходные данные --- одно целое число --- минимальное количество вставляемых символов.

Пример: путём вставки двух символов строка <<Ab3bd>> может быть преобразована
в палиндром (<<dAb3bAd>> или <<Adb3bdA>>).

Определим функцию $f[i,j]$ ($i, j \in 1..n$) как минимальное количество символов, которые
необходимо вставить в подстроку $S[i,j]$ для того, чтобы получить из неё палиндром.
Искомый результат --- $f[1,n]$.

Рассмотрим подстроку $S[i,j]$. Если символы $S[i]$ и $S[j]$ совпадают, то для преобразования её
в палиндром требуется столько же символов, сколько для преобразования подстроки $S[i+1,j-1]$.
При несовпадении символов требуется добавить один символ или к подстроке $S[i+1,j]$ или 
к подстроке $S[i,j-1]$, выбрав ту из них, в которую нужно добавить меньше символов для
преобразование в палиндром.
Рекуррентное соотношение имеет вид:
$$
  f[i,j] = \left\{\begin{array}{l}
      0, \quad \text{при $i \ge j$} \\
      f[i+1, j-1], \quad \text{при $S[i] = S[j]$ и $i < j$} \\
      min(f[i+1,j], f[i, j-1]) + 1, \quad \text{при $S[i] \neq S[j]$ и $i < j$} \\
  \end{array}\right.
$$

Пример. Пусть $S = abcdba3$. Значения $f$ приведены в следующей таблице:

$$\begin{array}{ccccccc}
0 & 1 & 2 & 3 & 2 & 1 & 2 \\
0 & 0 & 1 & 2 & 1 & 2 & 3 \\
0 & 0 & 0 & 1 & 2 & 3 & 4 \\
0 & 0 & 0 & 0 & 1 & 2 & 3 \\
0 & 0 & 0 & 0 & 0 & 1 & 2 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\end{array}$$

При реализации лучше не заводить целый двумерный массив, а использовать два
одномерных при последовательном вычислении строк снизу вверх.
В этих $n$ итерациях по строкам вычисляются элементы от $1$ до $n$ для каждой из них.
Ответом будет последний элемент последней вычисленной строки (то есть первой строки
матрицы). Временная сложность такого решения --- $O(n^2)$.

\begin{lstlisting}
int f[2][maxn];
std::string s;

int main()
{
    std::cin >> s;
    int n = (int)s.size();
    int c = 0;
    for (int i = n - 1 ; i >= 0 ; --i)
    {
        for (int j = i + 1 ; j < n ; ++j)
        {
            if (s[i] == s[j])
            {
                f[1-c][j] = f[c][j];
            }
            else
            {
                f[1-c][j] = 1 + std::min(f[c][j], f[1-c][j-1]);
            }
        }
        c = 1 - c;
    }
    std::cout << f[c][n - 1];
}
\end{lstlisting}

\section{Самый длинный палиндром}

Требуется найти самый длинный палиндром $P$, получающийся из строки $S$ удалением некоторых
(или никаких) символов. Длина $S$ не превышает $1000$.

Обозначим через $n$ длину строки $S$. Найдём длину максимального палиндрома, получающегося
удалением символов из строки $S[1..n]$. Рассмотрим крайние символы строки.
Если $S[1]$ удаляется, то следует перейти к решению подзадачи $S[2..n]$. Если же он
не удаляется, то он является частью палиндрома и должен совпадать с символом с другого конца
строки, то есть $S[1] = S[n]$. Тогда длина палиндрома будет равна $2$ плюс результат
решения подзадачи для строки $S[2..n-1]$. При отсутствии равенства нужно также рассмотреть
подзадачу $S[1..n-1]$.

Пусть $f[i,j]$ --- длина максимального палиндрома для подстроки $S[i..j]$. Тогда верно
следующее рекуррентное соотношение:

$$
  f[i,j] = \left\{\begin{array}{l}
      0, \quad \text{при $i > j$} \\
      1, \quad \text{при $i = j$} \\
      f[i+1, j-1] + 2, \quad \text{при $S[i] = S[j]$} \\
      \max(f[i+1, j], f[i, j-1]) \\
  \end{array}\right.
$$

Решение, находящее длину палиндрома, выглядит следующим образом:

\begin{lstlisting}
int f[maxn][maxn];

void solve(const std::string &s)
{
    int n = (int)s.size();
    for (int i = 0 ; i < n ; ++i)
        f[i][i] = 1;
    for (int len = 2 ; len <= n ; ++len)
    {
        for (int i = 0 ; i < n - len + 1 ; ++i)
        {
            int j = i + len - 1;
            if (s[i] == s[j])
            {
                f[i][j] = f[i+1, j-1] + 2;
            }
            else
            {
                f[i][j] = std::max(f[i+1][j], f[i][j-1]);
            }
        }
    }
    std::cout << f[0][n-1];
}
\end{lstlisting}

Заполнение таблицы производится от меньшей длины к большей, так как
при получении решения из подзадач обращения происходят только к подзадачам
меньшей длины.

Для вывода самого палиндрома требуется дополнительная информация о том, как
вычислялась функция $f[i,j]$. Будем записывать в двумерный массив $a$ следующие
значения:
$$
  a[i,j] = \left\{\begin{array}{l}
      0, \quad \text{если $f[i,j]$ получено из $f[i+1,j-1]$} \\
      1, \quad \text{если $f[i,j]$ получено из $f[i+1,j]$} \\
      2, \quad \text{если $f[i,j]$ получено из $f[i,j-1]$} \\
  \end{array}\right.
$$

С помощью этой информации можно построить рекурсивную процедуру вывода
палиндрома:

\begin{lstlisting}
void print(const std::string &s, int i, int j)
{
    if (i > j)
        return;
    if (i == j)
    {
        std::cout << s[i];
        return;
    }
    if (a[i][j] == 0)
    {
        std::cout << s[i];
        print(s, i + 1, j - 1);
        std::cout << s[j];
    }
    else if (a[i][j] == 1)
    {
        print(s, i + 1, j);
    }
    else
    {
        print(s, i, j - 1);
    }
}
\end{lstlisting}

\section{Наибольшая общая подпоследовательность}

\section{Упражнения}

\begin{enumerate}

\item Даны три последовательности целых чисел. Найти их наибольшую общую подпоследовательность.

\item Задан шаблон, состоящий из круглых скобок и знаков вопроса. Требуется определить, сколькими
      способами можно заменить знаки вопроса круглыми скобками так, чтобы получилась правильная
      скобочная последовательность.

\end{enumerate}

\chapter{Задачи на подмножествах}

\section{Размен}

В банкомате имеется банкноты nn различных номиналов $a_1, a_2, \ldots, a_n$. Клиент хочет получить сумму в $K$ денежных единиц. Необходимо определить, при помощи какого минимального числа банкнот можно выдать эту сумму (а при необходимости восстановления ответа - определить способ выдачи, использующий минимальное число банкнот).

\section{Задача о рюкзаке}

Есть $n$ золотых слитков массами $a_1, a_2, \ldots, a_n$. Какую максимальную массу золота можно унести, если она не может превышать $K$.

ДИСКРЕТНАЯ ЗАДАЧА ОБ УКЛАДКЕ РЮКЗАКА

Следующим обобщением задачи про золотые слитки является <<задача об укладке рюкзака>>. В этой задаче также имеется несколько предметов, для каждого предмета заданы две характеристики: вес $w_i > 0$ и стоимость предмета $p_i > 0$. Необходимо выбрать множество предметов суммарной максимальной стоимости, при этом суммарная масса выбранных предметов должна быть ограничена значением $K$.

\section{Задача линейного разбиения}

Дано множество $S$ положительных чисел $\{s_1, \ldots , s_n\}$ и натуральное число $k$.
Нужно разделить $S$ на $k$ подмножеств, чтобы максимальная из сумм элементов подмножеств была 
как можно меньше. При этом элементы каждого подмножества расположены рядом в исходном множестве.

То есть нужно установить во всем множестве $k-1$ разделитель, чтобы выполнялось условие.
$k$-й раздел начинается после $(k-1)$-го разделителя. Где мы можем поставить этот последний
разделитель? Между элементами $i$ и $i+1$. Каковы будут наши затраты на эту операцию?
Общая стоимость будет большей из двух величин: стоимость последнего раздела $\sum_{j=i+1}^{n}s_j$
или стоимость наибольшего раздела, созданного слева от $i$. Каким будет размер этого левого раздела?
Нужно разделить оставшиеся $\{s_1,\ldots s_j\}$ элементов, используя $k-2$ разделителей.
А это та же самая задача, только меньшего размера, поэтому её можно решить рекурсивно.

Исходя из этого, определим $M[n, k]$ как минимально возможную стоимость по всем операциям
разбиения множества $\{s_1, \ldots , s_n\}$ на $k$ подмножеств, где стоимость разбиения
определяется как наибольшая сумма элементов в одной из её частей. Теперь мы можем вычислить
значения этой функции:
$$ M[n,k] = \min_{i=1}^{n}\max\left(M[i,k-1], \sum_{j=i+1}^{n}s_j\right)$$

Для рекуррентного соотношения необходимо указать граничные условия. Они устанавливают
наименьшие возможные значения для всех аргументов. Для этой задачи наименьшим значением
первого аргумента будет $n=1$, что означает, что первый раздел состоит из одного элемента.
Наименьшим значением второго аргумента будет $k=1$, что означает, что множество $S$
вообще не разбивается на подмножества. Таким образом,
\begin{align*}
M[1,1] &= s_1 \\
M[n,1] &= \sum_{i=1}^{n}s_i
\end{align*}

Сколько времени уйдёт на вычисление нужного значения, если сохранять частичные результаты?
Всего в таблице $kn$ ячеек. Для вычисления $M[n,k]$ требуется найти минимальную из $n$ величин
в таблице поиска и из суммы в $n$ элементов. Если заполнение каждой из $kn$ ячеек занимает время 
$O(n^2)$, то всю рекуррентность можно вычислить за время $O(kn^3)$.

\begin{lstlisting}
int m[MAXN+1][MAXK+1];
int d[MAXN+1][MAXK+1];
int p[MAXN+1];

void partition(int s[], int n, int k)
{
    for (int i = 1 ; i <= n ; ++i)
        p[i] = p[i-1] + s[i];

    m[1][1] = s[1];
    for (int i = 1 ; i <= n ; ++i)
        m[i][1] = p[i];

    for (int i = 2 ; i <= n ; ++i)
    {
        for (int j = 2 ; j <= k ; ++j)
        {
            m[i][j] = MAXINT;
            for (int x = 1 ; x <= i-1 ; ++x)
            {
                int cost = max(m[x][j-1], p[i] - p[x]);
                if (m[i][j] > cost)
                {
                    m[i][j] = cost;
                    d[i][j] = x;
                }
            }
        }
    }
}
\end{lstlisting}

Таблица префиксных сумм нужна для того, чтобы экономить время на расчёте суммы
значений $s_i$ для каждой ячейки таблицы $m$. Так как $p[i] = \sum_{k=1}^{i}s_k$,
то $\sum_{k=i+1}^{j}s_k = p[j] - p[i]$. Это позволяет вычислять каждую ячейку за
$O(n)$, что даёт время выполнения всего алгоритма $O(kn^2)$.

Для восстановления оптимального решения используется матрица $D$. В неё мы записываем
позицию разделителя, которая требовалась для получения значения $M[i,j]$. Чтобы
восстановить путь, который приёл к оптимальному решению, мы идём назад от $D[n,k]$
и добавляем разделитель в каждой указанной позиции. Эту обратную трассировку можно
выполнять с помощью рекурсивной процедуры в следующем листинге:

\begin{lstlisting}
void print(int s[], int start, int end)
{
    for (int i = start ; i <= end ; ++i)
        printf("%d ", s[i]);
    printf("\n");
}

void reconstruct(int s[], int n, int k)
{
    if (k == 1)
    {
        print(s, 1, n);
    }
    else
    {
        reconstruct(s, d[n][k], k-1);
        print(s, d[n][k] + 1, n);
    }
}
\end{lstlisting}


\section{Наилучшее расписание}

На прямой задано множество отрезков $S$. Каждому отрезку $s_i \in S$ присвоен вес $v(s_i)$.
Требуется найти максимвльное по суммарному весу подмножество попарно непересекающихся отрезков.

Предствим себе ученика, которому на выбор предложен набор факультативных занятий $S$, идущих
в определённое время. Предположим, что каждому факультативу $s_i$ можно сопоставить
его полезность (или интересность) $v(s_i)$. В таком случае хочется знать, какое подмножество
всех факультативов надо выбрать, чтобы получить максимальную пользу от их посещения.

Полный перебор всех подмножеств $S$ потребует времени $O(2^n)$, поэтому желательно найти другое
решение. Для применения динамического программирования необходимо разбить задачу на подзадачи.
Определим функцию
$$Profit(s_i) = v(s_i) + \max_{s_j \prec s_i}Profit(s_j)$$,
где запись $s_j \prec s_i$ означает, что отрезок $s_j$ лежит левее отрезка $s_i$ и они
не накладываются друг на друга. В случае, если таких отрезков нет, полагаем
$Profit(s_i) = v(s_i)$.

Таким образом, $Profit(s_i)$ --- максимальный вес подмножества непересекающихся отрезков,
которое содержит $s_i$ и, возможно, некоторые отрезки, расположенные левее.

\begin{lstlisting}
int p[N];
int f[N];
struct {int a, b, v; } seg[N];

int profit(int i)
{
    if (p[i] == 0)
    {
        int k = -1;
        int m = 0;
        for (int j = 0 ; j < N ; ++j)
            if (seg[j].b <= seg[i].a && profit(j) > m)
            {
                k = j;
                m = profit(j);
            }
        f[i] = k;
        p[i] = m + seg[i].v;
    }
    return p[i];
}
\end{lstlisting}

Если мы определим максимум функции $Profit$ по всем отрезкам, то получим ответ на исходную задачу.
В некоторых случаях больший практический интерес представляет не максимальный вес, а дающее его
множество отрезков. Для того, чтобы восстановить набор отрезков, в программу введён массив $f$,
в котором для каждого отрезка хранится предшествующий ему в оптимальном наборе.

\section{Количество способов решения задачи (задача о кузнечике)}

Рассмотрим следующую задачу. На числовой прямой сидит кузнечик, который может прыгать вправо на одну или на две единицы. Первоначально кузнечик находится в точке с координатой 0. Определите количество различных маршрутов кузнечика, приводящих его в точку с координатой n.

\section{Наилучшее решение задачи (задача о кузнечике со стоимостями)}

Пусть кузнечик прыгает на одну или две точки вперед, а за прыжок в каждую точку необходимо заплатить определенную стоимость, различную для различных точек. Стоимость прыжка в точку i задается значением Price[i] списка Price. Необходимо найти минимальную стоимость маршрута кузнечика из точки 0 в точку n.

\section{Наибольшая возрастающая подпоследовательность}

Пример исходной последовательности: $\S=\{2,4,3,5,1,7,6,9,8\}$. Самая длинная возрастающая
подпоследовательность последовательности $S$ состоит из пяти элементов: $\{2,3,5,6,8\}$.

Как определить какие элементы последовательности нужно пропустить? Чтобы применить динамическое
программирование, нужно создать рекуррентное соотношение, которое вычисляет длину
наибольшей возрастающей подпоследовательнсти.

Какая информация о первых $n-1$ элементах последовательности $S$ помогла бы найти решение для
всей последовательности? Как минимум, нам нужно знать длину наибольшей возрастающей 
подпоследовательности для $s_1 \ldots s_{n-1}$. Но длины недостаточно для получения полного
решения. Пусть найденная длина решения для $s_1 \ldots s_{n-1}$ равна $5$. Если $s_n = 9$,
то увеличится ли длина наибольшей возрастающей подпоследовательности для множества
$s_1 \ldots s_n$?

Поэтому определим $l_i$, как количество чисел самой длинной возрастающей последовательности,
заканчивающейся на $s_i$. Тогда самая длинная возрастающая подпоследовательность, содержащая
$s_n$, получается в результате добавления этого числа в конец самой длинной возрастающей
последовательности слева от $s_n$ и оканчивающейся числом, меньшим, чем $s_n$. Длина $l_i$
вычисляется с помощью следующего рекуррентного соотношения:

\begin{align*}
l_0 &= 0 \\
l_i &= \max_{0<j<i}(l_j + 1), \quad \text{ где $s_j < s_i$}
\end{align*}

Эти значения определяют количество элементов в самой длинной возрастающей последовательности,
заканчивающейся определенным числом. Количество элементов в наибольшей возрастающей
подпоследовательности полной последовательности можно выразить формулой $\max_{1\le i\le n}l_i$,
так как лучшая последовательность должна заканчиваться на один из элементов $S$.

Какую вспомогательную информацию нам следует сохранить, чтобы восстановить саму
последовательность, а не только её длину? Для каждого элемента $s_i$ сохраняется его
предшественник, а именно индекс $p_i$ элемента, непосредственно предшествующего $s_i$
в наибольшей возрастающей подпоследовательности, оканчивающейся на $s_i$. Так как все
эти указатели направлены влево, то самую длинную последовательность можно восстановить,
начав с её последнего значения и следуя указателям на другие её члены.

Какова временная сложность этого алгоритма? Если каждое из $n$ значений $l_i$ вычисляется
путём сравнения $s_i$ с $i-1$ значениями слева от него, то общее время этого анализа
будет равно $O(n^2)$.

\begin{tabular}{l|c|c|c|c|c|c|c|c|c}
Последовательность $s_i$ & 2 & 4 & 3 & 5 & 1 & 7 & 6 & 9 & 8 \\
\hline
Длина $l_i$              & 1 & 2 & 3 & 3 & 1 & 4 & 4 & 5 & 5 \\
\hline
Предшественник $p_i$     &   & 1 & 1 & 2 &   & 4 & 4 & 6 & 6 \\
\end{tabular}




\chapter{Задачи на деревьях}

\chapter{Динамическое программирование по профилю}

\chapter{Динамическое программирование и игры с полной информацией}

\part{Всё подряд}

\chapter{Рекуррентные соотношения}



\section{Число перестановок и факториал}

\section{Числа Стирлинга второго рода}

Числа Стирлинга второго рода --- число разбиений множества из $n$ элементов на $k$
непустых подмножеств. Обозначаются числа Стирлинга второго рода как $\stirling{n}{k}$.
Так, существует семь способор разбиения четырехэлементного множества на две части:
$$
  \{1,2,3\}\cup\{4\}, \quad \{1,2,4\}\cup\{3\}, \quad \{1,3,4\}\cup\{2\}, \quad \{2,3,4\}\cup\{1\},
  \quad \{1,2\}\cup\{3,4\}, \quad \{1,3\}\cup\{2,4\}, \quad \{1,4\}\cup\{2,3\}
$$

Следовательно, $\stirling{4}{2} = 7$.

Существует только один способ помещения $n$ элементов в одно непустое подмножество.
Следовательно, $\stirling{n}{1} = 1$ при любом $n>0$. С другой стороны, $\stirling{0}{1} = 0$,
потому что $0$-элементное множество пусто. $\stirling{0}{0} = 1$, потому что пустое множество
можно разбить на нулевое число подмножеств только одним способом. А $\stirling{n}{0} = 0$ для
$n>0$, потому что элементы множества нужно поместить хотя бы в одну часть.

Чтобы вычислить $\stirling{n}{k}$, можно использовать следующие рассуждения.
Последний объект из заданных $n$ можно поместить в отдельное подмножество. Остальные можно
разбить на множества $\stirling{n-1}{k-1}$ способами. Либо этот объект можно поместить
в одну из $k$ частей, полученных из $n-1$ объектов. Количество разбиений на такие части
будет равняться $\stirling{n-1}{k}$. Для каждого есть $k$ способов размещения последнего
элемента.
Следовательно,

$$\stirling{n}{k} = k\stirling{n-1}{k} + \stirling{n-1}{k-1}, \text{ для $n>0$}$$

\section{Числа Эйлера}

Число Эйлера $\euler{n}{k}$ --- это число перестановок $\pi_1\pi_2\ldots\pi_n$
множества $\{1,2,\ldots,n\}$, имеющих
$k$ участков подъема, а именно, $k$ мест, где $\pi_j<\pi_{j+1}$.

К примеру, одиннадцать перестановок множества $\{1,2,3,4\}$ содержат по
два участка подъема: $$1324, 1423, 2314, 2413, 3412, 1243, 1342, 2341, 2134, 3124, 4123$$.

Найдём рекуррентность для $\euler{n}{k}$. Каждая перестановка $\pi = \pi_1\pi_2\ldots\pi_{n-1}$
множества $\{1,\ldots,n-1\}$ приводит к $n$ перестановкам множества $\{1,\ldots,n\}$,
если вставлять новый элемент во все возможные места. Предположим, мы вставляем $n$ на $j$-е
место, получая $\pi' = \pi_1\ldots\pi_{j-1}n\pi_j\ldots\pi_{n-1}$. Если $j=1$ или если
$\pi_{j-1} < \pi_j$, то число участков подъема в $\pi'$ такое же, как и в $\pi$. Если же
$\pi_{j-1} > \pi_j$ или же $j=n$, то оно на единицу больше числа участков подъёма в $\pi$.
Поэтому в целом перестановка $\pi'$ с $k$ участками подъёма получается $(k+1)\euler{n-1}{k}$
способами из перестановок $\pi$, которые содержат $k$ участков подъёма, плюс
$((n-2)-(k-1)+1)\euler{n-1}{k-1}$ способами из перестановок $\pi$, которые содержат
$k-1$ участков подъёма.

Итак, искомая рекуррентность:
\begin{align*}
\euler{0}{k} &= [k = 0] \\
\euler{n}{k} &= (k+1)\euler{n-1}{k} + (n-k)\euler{n-1}{k-1}, \text{ для $n>0$} \\
\end{align*}



%\section{? Производящие функции}

%\section{? Свертки}

\chapter{Динамическое программирование}

\section{Одномерное динамическое программирование}

\section{Двумерное динамическое программирование}

\chapter{Перебор и динамическое программирование}

\chapter{Упражнения}
\begin{enumerate}

\item Решите рекуррентное соотношение
$$
\begin{array}{ll}
g_0 = 1; \\
g_n = g_{n-1} + 2g_{n-2} + \cdots + ng_0 & n>0
\end{array}
$$

\item Сколько существует способов разместить числа ${1, 2, \ldots , 2n}$ 
в виде массива размера $2 \times n$ так, чтобы и строки и столбцы массива
были упорядочены по возрастанию слева направо и сверху вниз?
Например, для $n=5$ одним из решений будет 
$$\begin{pmatrix}
1 & 2 & 4 & 5 & 8 \\
3 & 6 & 7 & 9 & 10 
\end{pmatrix}$$.

\item Число Бэлла $\varpi_n$ --- число способов разбиения множества из $n$ предметов на подмножества.
      Например, $\varpi_3=5$, поскольку множество $\{1,2,3\}$ можно разбить на такие подмножества:
      $$\{1,2,3\}; \{1,2\}\cup\{3\}; \{1,3\}\cup\{2\}; \{1\}\cup\{2,3\}; \{1\}\cup\{2\}\cup\{3\}; $$
      Найдите выражение для $\varpi_n$.

\item Если $S$ --- некоторое множество целых чисел, то пусть $S+1$ будет <<сдвинутым>>
множеством $\{x+1 \mid x \in S\}$. Сколько подмножеств множества $\{1,2,\ldots,n\}$ обладают
тем свойством, что $S\cup(S+1) = \{1,2,\ldots,n+1\}$.

\end{enumerate}

\section{Ответы}
\begin{enumerate}

\item $G(z)=(z/(1-z)^2)G(z)+1$, следовательно 
$$G(z) = \frac{1-2z+z^2}{1-3z+z^2} = 1 + \frac{z}{1-3z+z^2};$$
поэтому имеем $g_n=F_{2n}+[n=0]$.

\item $C_n$. Числа в верхнем ряду соответствуют позициям плюс единиц в последовательности
из $+1$ и $-1$, определяющей <<горную гряду>>; числа нижнего ряда отвечают позициям
минус единиц. Например, приведенный в упражнении массив соответствует
\begin{verbatim}
    /\     
 /\/  \/\  
/        \ 
\end{verbatim}.

\item $\varpi_n = \sum_k C_n^k\varpi_{n-k}$

\item $F_n$.

\end{enumerate}

\part{Задачи}

\end{document} 
