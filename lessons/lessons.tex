\documentclass[14pt,openany]{book}

\include{preamble}

\begin{document}

\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\clearpage

\part{Занятия}

\chapter{Рекуррентные соотношения}

\input{lesson_recurrent}

\section{Задачи}

\input{tasks01}

\section{Ответы на задачи}

\begin{enumerate}
\item Если новая $n$-я прямая пересекает прежние прямые в $k>0$ различных точках,
мы получаем $k-1$ новых конечных областей (в предположении, что ни одна из прежних прямых
не параллельна никакой другой) и $2$ новые бесконечные области. Следовательно, максимальное
число конечных областей равно $(n-2) + (n-3) + \cdots = S_{n-2} = (n-1)(n-2)/2 = L_n-2n$.

\item 233 способами

\item Пусть $a_n$ --— количество способов, которыми кузнечик может добраться до $n$-ой клетки. Тогда $a_1 = a_2 = 1$. Кроме того, в $n+1$-ую клетку кузнечик может попасть либо из $n$-ой клетки, либо перепрыгнув $n$-ую клетку. Поэтому $a_{n + 1} = a_{n - 1} + a_n$. Отсюда $a_n = F_{n - 1}$. 

\item $F_{n + 1}$.

\item По условию  $a_2 = a_1a_3, a_3 = a_2a_4, \ldots, a_{99} = a_{98}a_{100}$.
      Перемножив два соседних равенства, получим $a_ka_{k+3} = 1$,  то есть 
      $a_{k+3} = \frac{1}{a_k}$. Значит, $a_{k+6} = a_k$. 
      Следовательно, $a_1 = a_7 = \cdots = a_{97} = 7$,
      а $a_{100} = \frac{1}{a_{97}} = \frac{1}{7}$.

\item $a_n = 2^n + 1 (n \ge 0)$

\item \begin{enumerate}
    \item Обозначим через $а_n$ число способов подняться на лестницу из $n$ ступенек, соблюдая условия задачи. Очевидно,  $a_1 = 1,  a_2 = 2$.
    
   Пусть Петя запрыгивает на лестницу из $n > 2$  ступенек. Если первый прыжок был на две ступеньки, то ему осталось запрыгнуть на  $n – 2$  ступеньки, и число способов закончить подъем равно $a_{n–2}$. Если же первый прыжок был на одну ступеньку, то число способов закончить подъем равно $a_{n–1}$. Значит, $a_n = a_{n–1} + a_{n–2}$.

   Это равенство позволяет, зная $a_1$ и $a_2$, вычислять последовательно все $a_n$ (при этом будут получаться известные числа Фибоначчи):
$a_3 = 3,  a_4 = 5,  a_5 = 8,  a_6 = 13,  a_7 = 21,  a_8 = 34,  a_9 = 55,  a_{10} = 89$.

   \item Каждую  из $9$ ступенек (кроме последней) Петя может либо перепрыгнуть, либо не перепрыгнуть независимо от того, на каких из верхних ступенек он останавливался. Поэтому количество способов спуститься по лестнице равно $2^9$.

 \end{enumerate}

\item Обозначим за $a_n$ количество слов длины $n$, состоящих только из букв <<а>> и <<б>> и не содержащих в записи двух букв <<б>> подряд. Таким образом, находим $a_1=2, a_2=3$. Покажем, что $a_n$ можно выразить через $a_{n-1}$ и $a_{n-2}$. Количество слов длины $n$, не содержащих в записи двух букв <<б>> подряд и начинающихся с буквы <<а>>, равно $a_{n-1}$, так как после первой буквы может следовать любое слово длины $n-1$, не содержащее двух <<б>> подряд. Пусть слово длины $n$ начинается с буквы <<б>>. Если в этом слове нет двух <<б>> подряд, то вторая буква --- <<а>>, а далее может следовать любое слово длины $n-2$, не содержащее двух <<б>> подряд. Таким образом, количество слов длины $n$, не содержащих в записи двух букв <<б>> подряд и начинающихся с буквы <<б>>, равно $a_{n-2}$. Тем самым, мы показали, что $a_n=a_{n-1}+a_{n-2}$. Теперь последовательно вычисляем $a_3=a_2+a_1=3+2=5$, $a_4=a_3+a_2=5+3=8$ и т.д., $a_{10}=a_9+a_8=144$. Заметим, что получающиеся числа $a_n$ --- это хорошо известные числа Фибоначчи. 

\item Заметим, что  $a_{n+3} = a_{n+2} – a_{n+1} = –a_n$.  Значит,  $a_{n+6} = a_n$,  то есть члены последовательности повторяются с периодом $6$. Так как $100$ при делении на $6$ дает остаток $4$, то  $a_{100} = a_4 = –a_1$.

\item Докажем требуемое утверждение по индукции. База индукции очевидна. Последовательность $\{a_n\}$ монотонно возрастает, поэтому для любого натурального числа $m$ можно выбрать $n$ так, что 
$a_n \le m < a_{n+1}$. По предположению индукции число $m - a_n$ (если оно отлично от нуля) можно представить в виде суммы нескольких разных членов последовательности $\{a_n\}$. При этом 
$m - a_n < a_{n + 1} - a_n = a_{n - 1}$. Значит, в этом разложении не присутствует даже 
$a_{n - 1}$, и, тем более, не присутствует $a_n$. 

\item 
  \begin{enumerate}
    \item $a_n = 3^n - 2^n$
    \item $a_n = 1$
    \item $a_n = F_{n+1}$
    \item $a_n = n + 1$
    \item $a_n = \frac{1}{2\sqrt{2}}\left(\left(1+\sqrt{2}\right)^n - \left(1-\sqrt{2}\right)^n\right)$
  \end{enumerate}

\item $\frac{1}{5}(3^n-(-2)^n)$

\item Ясно, что после четного числа прыжков лягушка может находиться только в вершинах $A$, $C$ или $E$. Обозначим через $a_k$, $c_k$, $e_k$ число путей длины $2k$, ведущих из $A$ в $A$, $C$ и $E$ соответственно. В силу симметрии  $c_k = e_k$.  Легко видеть, что выполняются равенства
      $c_{k+1} = a_k + 3c_k$, $a_{k+1} = 2a_k + 2c_k$.
   Отсюда
      $c_{k+2} = a_{k+1} + 3c_{k+1} = 2a_k + 2c_k + 3c_{k+1} = 2(c_{k+1} - 3c_k) + 2c_k + 3c_{k+1} = 5c_{k+1} - 4c_k$.

   Из начальных условий $c_0 = 0,  c_1 = 1$,   находим $c_k = \frac{4^k - 1}{3}$ (это нетрудно доказать по индукции).
   Для второй подзадачи обозначим через $b_k$ число путей длины  $2k - 1$,  ведущих из $A$ в $B$. Тогда   $b_{k+1} = 3b_k$  (за два прыжка можно двумя способами вернуться из $B$ в $B$ и одним способом попасть из $B$ в $F$). Но $c_k = b_k$,   значит,
$c_{k+1} = 3c_k$  при  $k > 0$.  По-прежнему,  $c_1 = 1$,  следовательно, $c_k = 3^{k-1}$.

\item    Пусть $a_n$ --- число способов вернуться за $n$ прыжков в исходную вершину, а $b_n$ --- попасть за $n$ прыжков в соседнюю вершину.
Легко видеть, что   $a_{n+1} = 2b_n$,  $b_{n+1} = a_n + b_n$.   Отсюда нетрудно вывести, что   $b_{n+2} = b_{n+1} + 2b_n$,  $a_{n+2} = a_{n+1} + 2a_n$.
   Из начальных условий $a_0 = 1$, $a_1 = 0$,   получаем $a_n = \frac{2^n + 2(-1)^n}{3}$ (это нетрудно доказать по индукции).

\item TODO

\item   Обозначим через $M_n$ число всевозможных маршрутов длительностью $n$ минут. Каждый такой маршрут состоит ровно из $n$ участков (участок –-- это отрезок $AB$, $BA$ или кольцо $BB$). Пусть  $M_{n,A}$ – число таких маршрутов, оканчивающихся в $A$, а $M_{n,B}$ – число маршрутов с конечной точкой $B$.
  В точку $B$ за минуту можно попасть как из точки $A$, так и из точки $B$, поэтому  $M_{n,B} = M_{n-1}$.
  В точку $A$ за минуту можно попасть только из точки $B$, поэтому  $M_{n,A} = M_{n-1,B} = M_{n-2} = M_{n-2,A} + M_{n-2,B} = M_{n-2,A} + M_{n-3} = M_{n-2,A} + M_{n-1,A}$. 
  Дополнительно заметим, что  $M_{1,A} = 0$, $M_{2,A} = 1$.  Таким образом, числа $M_{n,A}$ образуют последовательность  $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \ldots$.
  Число $M_{10,A}$ равно $34$ --- девятому числу Фибоначчи.


\end{enumerate}

% \chapter{Ещё рекуррентные соотношения}

\chapter{Вычисление рекуррентностей на компьютере}

\input{lesson_recurrent2}

\input{lesson_recurrent3}

\section{Задачи}

\input{tasks02}

\section{Ответы на задачи}

\begin{enumerate}
\item Подставим в производящую функцию $z^4$ вместо | и z вместо -. Получим функцию $1/(1-z^4-z^2)$.
Это похоже на производящую функцию для $T$, однако $z$ заменено на $z^2$. Следовательно, 
ответом будет $0$ для нечетных $m$ и $F_{m/2+1}$ --- для четных.

\item Это задача размена с номиналами монет $10$ и $20$, поэтому $G(z)=(1/(1-z^{10})(1-z^{20})$.

\item Обозначим искомое число $a_n$, а через $b_n$ обозначим разбиение колонны с выемкой размера
      $2 \times 2 \times 1$ вверху. Рассматривая различные варианты расположения видимых сверху
      кирпичей, получим
$$
\begin{array}{ll}
a_n = 2a_{n-1} + 4b_{n-1} + a_{n-2} + [n=0]; \\
b_n = a_{n-1} + b_{n-1}.
\end{array}
$$
      Следовательно, производящие функции удовлетворяют уравнениям $A = 2zA+4zB+z^2A+1$ и
      $B = zA + zB$. Откуда находим $$A(z) = \frac{1-z}{(1+z)(1-4z+z^2)}$$
      $$a_n = \frac{1}{6}(2+\sqrt{3})^{n+1} + \frac{1}{6}(2-\sqrt{3})^{n+1} + \frac{1}{3}(-1)^n$$

\item Пусть $a_n$ --- число цепочек ДНК, которые не заканчиваются на $c$ или $e$, а $b_n$ --- число
      цепочек, заканчивающихся этими символами. Тогда
      $$
      \begin{array}{ll}
      a_n = 3a_{n-1}+2b_{n-1}+[n=0], & b_n = 2a_{n-1} + b_{n-1}, \\
      A(z) = 3zA(z) + 2zB(z) + 1,    & B(z) = 2zA(z) + zB(z), \\
      A(z) = \frac{1-z}{1-4z-z^2},   & B(z) = \frac{2z}{1-4z-z^2}. \\
      \end{array}
      $$
      Общее число цепочек равно $[z^n](1+z)/(1-4z-z^2) = F_{3n+2}$.

\item $P_0 = 1$, $P_1 = p$, $P_k = p\cdotP_{k-2}$.

\item $L_n = L_{n-1} + L_{n-2} + L_{n-3}$

\item TODO

\item TODO

\end{enumerate}

\chapter{Динамическое программирование}

\input{lesson_dynamic}

\chapter{Задачи с одним параметром}

\input{lesson_1dimension}

\section{Упражнения}

\input{tasks04}

\chapter{Двумерное динамическое программирование}

\section{Биномиальные коэффициенты}

Биномиальные коэффициенты удобнее всего вычислять с помощью соотношения~\ref{formula-binom-rec}.
Заполняя клетки в таблице, содержащей треугольник Паскаля, сверху вниз, мы можем
использовать уже вычисленные значения, так как правая часть формулы ссылается только на
предыдущую строку.

$$
 \begin{array}{ccccccc}
 n & \binom{n}{0} & \binom{n}{1} & \binom{n}{2} & \binom{n}{3} & \binom{n}{4} & \binom{n}{5} \\
 0 & 1 \\
 1 & 1 & 1 \\
 2 &  1 & 2 & 1 \\
 3 & 1 & 3 & 3 & 1 \\
 4 & 1 & 4 & 6 & 4 & 1 \\
 5 & 1 & 5 & 10 & 10 & 5 & 1
 \end{array}
$$

\begin{lstlisting}
const int N = 20;
int c[N + 1][N + 1];

void fill_binom()
{
    c[0][0] = 1;
    for (int i = 1 ; i <= N ; ++i)
    {
        c[i][0] = 1;
        for (int j = 1 ; j <= i ; ++j)
            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
    }
}
\end{lstlisting}

\section{Упражнения}

\begin{enumerate}

\item Найти минимальное натуральное число с заданной суммов кубов цифр.

\item Натуральное число назовём <<плавным>>, если разность двух его соседних цифр не превосходит
      по модулю единицы. Определить количество $n$-значных <<плавных>> чисел.

\end{enumerate}

\chapter{Задачи на матрицах}

\section{Путь в матрице 1}

На плоскости из любой точки $(x, y)$ разрешается перемещаться в точку $(x+1,y)$ или $(x,y+1)$.
Сколькими способами можно добраться из начала координат $(0,0)$ в точку $(m,n)$?

Обозначим через $ways(x,y)$ количество путей, ведущих из начала координат в точку $(x,y)$.
Тогда справедливо рекуррентное соотношение
\begin{align*}
ways(0,0) &= 1 \\
ways(x,y) &= ways(x-1,y) + ways(x,y-1)
\end{align*}

В программе мы можем завести одноимённую таблицу $ways$ и заполнить её, получив интересующее
нас значение $ways[m][n]$. Задачу мы будем решать снизу вверх, чтобы избежать накладных
расходов, связанных с рекурсивными вызовами.

\begin{lstlisting}
int count(int m, int n)
{
    int ways[MAXM + 1][MAXN + 1];
    for (int x = 0 ; x <= m ; ++x)
    {
        for (int y = 0 ; y <= n ; ++y)
        {
            if (x > 0)
            {
                if (y > 0)
	            {
                    ways[x][y] = ways[x-1][y] + ways[x][y-1];
	            }
                else
                {
                    ways[x][y] = ways[x - 1][y];
                }
            }
            else
            {
                if (y > 0)
                {
                    ways[x][y] = ways[x][y - 1];
                }
                else
                {
                    ways[x][y] = 1;
                }
            }
        }
    }
    return ways[m][n];
}
\end{lstlisting}

В этой программе всегда заполняется только одна строка на основе данных из предыдущей.
Поэтому можно двумерный массив свести к одномерному:

\begin{lstlisting}
int count(int m, int n)
{
    int ways[MAXN + 1];
    for (int y = 0 ; y <= n ; ++y)
        ways[y] = 1;
    for (int x = 1 ; x <= m ; ++x)
        for (int y = 1 ; y <= n ; ++y)
       	    ways[y] += ways[y-1];
    return ways[m][n];
}
\end{lstlisting}

\section{Путь в матрице 2}

Рассмотрим шахматную доску в левом верхнем углу которой находится король. Король может перемещаться только вправо, вниз или по диагонали вправо-вниз на одну клетку. Необходимо определить количество различных маршрутов короля, приводящих его в правый нижний угол.

Теперь решим задачу о нахождении маршрута минимальной стоимости из левого верхнего угла в правый нижний, считая что для каждой клетке указана стоимость прохода через эту клетку.

Игры

\section{Игра <<Ферзя в угол>>}

Рассмотрим игру <<Ферзя в угол>> для двух игроков. В левом верхнем углу доски размером $n \times m$ 
находится ферзь, который может двигаться только вправо-вниз. Игроки по очереди двигают ферзя, то есть 
за один ход игрок может переместить ферзя либо по вертикали вниз, либо по горизонтали вправо, либо во 
диагонали вправо-вниз. Игрок, который не может сделать ход — проигрывает, иными словами, выигрывает 
игрок, который поставит ферзя в правый нижний угол. Необходимо определить, какой из игроков может 
выиграть в этой игре независимо от ходов другого игрока.


\chapter{Задачи на отрезках}

Задачи на отрезках могут определяться на некоторой строке символов, последовательности чисел
и т.п. Решение полной задачи определяется через решение задач для подотрезков.

\section{Палиндром}

Палиндром --- это симметричная строка, то есть она одинаково читается как слева направо,
так и справа налево. Требуется по заданной строке определить минимальное количество
символов,
которые необходимо вставить в строку для преобразования её в палиндром.

Входные данные --- строка $S$ длиной $n$ символов ($3 \le n \le 5000$).
Выходные данные --- одно целое число --- минимальное количество вставляемых символов.

Пример: путём вставки двух символов строка <<Ab3bd>> может быть преобразована
в палиндром (<<dAb3bAd>> или <<Adb3bdA>>).

Определим функцию $f[i,j]$ ($i, j \in 1..n$) как минимальное количество символов, которые
необходимо вставить в подстроку $S[i,j]$ для того, чтобы получить из неё палиндром.
Искомый результат --- $f[1,n]$.

Рассмотрим подстроку $S[i,j]$. Если символы $S[i]$ и $S[j]$ совпадают, то для преобразования её
в палиндром требуется столько же символов, сколько для преобразования подстроки $S[i+1,j-1]$.
При несовпадении символов требуется добавить один символ или к подстроке $S[i+1,j]$ или 
к подстроке $S[i,j-1]$, выбрав ту из них, в которую нужно добавить меньше символов для
преобразование в палиндром.
Рекуррентное соотношение имеет вид:
$$
  f[i,j] = \left\{\begin{array}{l}
      0, \quad \text{при $i \ge j$} \\
      f[i+1, j-1], \quad \text{при $S[i] = S[j]$ и $i < j$} \\
      min(f[i+1,j], f[i, j-1]) + 1, \quad \text{при $S[i] \neq S[j]$ и $i < j$} \\
  \end{array}\right.
$$

Пример. Пусть $S = abcdba3$. Значения $f$ приведены в следующей таблице:

$$\begin{array}{ccccccc}
0 & 1 & 2 & 3 & 2 & 1 & 2 \\
0 & 0 & 1 & 2 & 1 & 2 & 3 \\
0 & 0 & 0 & 1 & 2 & 3 & 4 \\
0 & 0 & 0 & 0 & 1 & 2 & 3 \\
0 & 0 & 0 & 0 & 0 & 1 & 2 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\end{array}$$

При реализации лучше не заводить целый двумерный массив, а использовать два
одномерных при последовательном вычислении строк снизу вверх.
В этих $n$ итерациях по строкам вычисляются элементы от $1$ до $n$ для каждой из них.
Ответом будет последний элемент последней вычисленной строки (то есть первой строки
матрицы). Временная сложность такого решения --- $O(n^2)$.

\begin{lstlisting}
int f[2][maxn];
std::string s;

int main()
{
    std::cin >> s;
    int n = (int)s.size();
    int c = 0;
    for (int i = n - 1 ; i >= 0 ; --i)
    {
        for (int j = i + 1 ; j < n ; ++j)
        {
            if (s[i] == s[j])
            {
                f[1-c][j] = f[c][j];
            }
            else
            {
                f[1-c][j] = 1 + std::min(f[c][j], f[1-c][j-1]);
            }
        }
        c = 1 - c;
    }
    std::cout << f[c][n - 1];
}
\end{lstlisting}

\section{Самый длинный палиндром}

Требуется найти самый длинный палиндром $P$, получающийся из строки $S$ удалением некоторых
(или никаких) символов. Длина $S$ не превышает $1000$.

Обозначим через $n$ длину строки $S$. Найдём длину максимального палиндрома, получающегося
удалением символов из строки $S[1..n]$. Рассмотрим крайние символы строки.
Если $S[1]$ удаляется, то следует перейти к решению подзадачи $S[2..n]$. Если же он
не удаляется, то он является частью палиндрома и должен совпадать с символом с другого конца
строки, то есть $S[1] = S[n]$. Тогда длина палиндрома будет равна $2$ плюс результат
решения подзадачи для строки $S[2..n-1]$. При отсутствии равенства нужно также рассмотреть
подзадачу $S[1..n-1]$.

Пусть $f[i,j]$ --- длина максимального палиндрома для подстроки $S[i..j]$. Тогда верно
следующее рекуррентное соотношение:

$$
  f[i,j] = \left\{\begin{array}{l}
      0, \quad \text{при $i > j$} \\
      1, \quad \text{при $i = j$} \\
      f[i+1, j-1] + 2, \quad \text{при $S[i] = S[j]$} \\
      \max(f[i+1, j], f[i, j-1]) \\
  \end{array}\right.
$$

Решение, находящее длину палиндрома, выглядит следующим образом:

\begin{lstlisting}
int f[maxn][maxn];

void solve(const std::string &s)
{
    int n = (int)s.size();
    for (int i = 0 ; i < n ; ++i)
        f[i][i] = 1;
    for (int len = 2 ; len <= n ; ++len)
    {
        for (int i = 0 ; i < n - len + 1 ; ++i)
        {
            int j = i + len - 1;
            if (s[i] == s[j])
            {
                f[i][j] = f[i+1, j-1] + 2;
            }
            else
            {
                f[i][j] = std::max(f[i+1][j], f[i][j-1]);
            }
        }
    }
    std::cout << f[0][n-1];
}
\end{lstlisting}

Заполнение таблицы производится от меньшей длины к большей, так как
при получении решения из подзадач обращения происходят только к подзадачам
меньшей длины.

Для вывода самого палиндрома требуется дополнительная информация о том, как
вычислялась функция $f[i,j]$. Будем записывать в двумерный массив $a$ следующие
значения:
$$
  a[i,j] = \left\{\begin{array}{l}
      0, \quad \text{если $f[i,j]$ получено из $f[i+1,j-1]$} \\
      1, \quad \text{если $f[i,j]$ получено из $f[i+1,j]$} \\
      2, \quad \text{если $f[i,j]$ получено из $f[i,j-1]$} \\
  \end{array}\right.
$$

С помощью этой информации можно построить рекурсивную процедуру вывода
палиндрома:

\begin{lstlisting}
void print(const std::string &s, int i, int j)
{
    if (i > j)
        return;
    if (i == j)
    {
        std::cout << s[i];
        return;
    }
    if (a[i][j] == 0)
    {
        std::cout << s[i];
        print(s, i + 1, j - 1);
        std::cout << s[j];
    }
    else if (a[i][j] == 1)
    {
        print(s, i + 1, j);
    }
    else
    {
        print(s, i, j - 1);
    }
}
\end{lstlisting}

\section{Наибольшая общая подпоследовательность}

\section{Упражнения}

\begin{enumerate}

\item Даны три последовательности целых чисел. Найти их наибольшую общую подпоследовательность.

\item Задан шаблон, состоящий из круглых скобок и знаков вопроса. Требуется определить, сколькими
      способами можно заменить знаки вопроса круглыми скобками так, чтобы получилась правильная
      скобочная последовательность.

\end{enumerate}

\chapter{Задачи на подмножествах}

\section{Размен}

В банкомате имеется банкноты $n$ различных номиналов $a_1, a_2, \ldots, a_n$. Клиент хочет получить сумму в $K$ денежных единиц. Необходимо определить, при помощи какого минимального числа банкнот можно выдать эту сумму (а при необходимости восстановления ответа --- определить способ выдачи, использующий минимальное число банкнот).

\section{Задача о рюкзаке}

Есть $n$ золотых слитков массами $a_1, a_2, \ldots, a_n$. Какую максимальную массу золота можно унести, если она не может превышать $K$.

ДИСКРЕТНАЯ ЗАДАЧА ОБ УКЛАДКЕ РЮКЗАКА

Следующим обобщением задачи про золотые слитки является <<задача об укладке рюкзака>>. В этой задаче также имеется несколько предметов, для каждого предмета заданы две характеристики: вес $w_i > 0$ и стоимость предмета $p_i > 0$. Необходимо выбрать множество предметов суммарной максимальной стоимости, при этом суммарная масса выбранных предметов должна быть ограничена значением $K$.

\section{Задача линейного разбиения}

Дано множество $S$ положительных чисел $\{s_1, \ldots , s_n\}$ и натуральное число $k$.
Нужно разделить $S$ на $k$ подмножеств, чтобы максимальная из сумм элементов подмножеств была 
как можно меньше. При этом элементы каждого подмножества расположены рядом в исходном множестве.

То есть нужно установить во всем множестве $k-1$ разделитель, чтобы выполнялось условие.
$k$-й раздел начинается после $(k-1)$-го разделителя. Где мы можем поставить этот последний
разделитель? Между элементами $i$ и $i+1$. Каковы будут наши затраты на эту операцию?
Общая стоимость будет большей из двух величин: стоимость последнего раздела $\sum_{j=i+1}^{n}s_j$
или стоимость наибольшего раздела, созданного слева от $i$. Каким будет размер этого левого раздела?
Нужно разделить оставшиеся $\{s_1,\ldots s_j\}$ элементов, используя $k-2$ разделителей.
А это та же самая задача, только меньшего размера, поэтому её можно решить рекурсивно.

Исходя из этого, определим $M[n, k]$ как минимально возможную стоимость по всем операциям
разбиения множества $\{s_1, \ldots , s_n\}$ на $k$ подмножеств, где стоимость разбиения
определяется как наибольшая сумма элементов в одной из её частей. Теперь мы можем вычислить
значения этой функции:
$$ M[n,k] = \min_{i=1}^{n}\max\left(M[i,k-1], \sum_{j=i+1}^{n}s_j\right)$$

Для рекуррентного соотношения необходимо указать граничные условия. Они устанавливают
наименьшие возможные значения для всех аргументов. Для этой задачи наименьшим значением
первого аргумента будет $n=1$, что означает, что первый раздел состоит из одного элемента.
Наименьшим значением второго аргумента будет $k=1$, что означает, что множество $S$
вообще не разбивается на подмножества. Таким образом,
\begin{align*}
M[1,1] &= s_1 \\
M[n,1] &= \sum_{i=1}^{n}s_i
\end{align*}

Сколько времени уйдёт на вычисление нужного значения, если сохранять частичные результаты?
Всего в таблице $kn$ ячеек. Для вычисления $M[n,k]$ требуется найти минимальную из $n$ величин
в таблице поиска и из суммы в $n$ элементов. Если заполнение каждой из $kn$ ячеек занимает время 
$O(n^2)$, то всю рекуррентность можно вычислить за время $O(kn^3)$.

\begin{lstlisting}
int m[MAXN+1][MAXK+1];
int d[MAXN+1][MAXK+1];
int p[MAXN+1];

void partition(int s[], int n, int k)
{
    for (int i = 1 ; i <= n ; ++i)
        p[i] = p[i-1] + s[i];

    m[1][1] = s[1];
    for (int i = 1 ; i <= n ; ++i)
        m[i][1] = p[i];

    for (int i = 2 ; i <= n ; ++i)
    {
        for (int j = 2 ; j <= k ; ++j)
        {
            m[i][j] = MAXINT;
            for (int x = 1 ; x <= i-1 ; ++x)
            {
                int cost = max(m[x][j-1], p[i] - p[x]);
                if (m[i][j] > cost)
                {
                    m[i][j] = cost;
                    d[i][j] = x;
                }
            }
        }
    }
}
\end{lstlisting}

Таблица префиксных сумм нужна для того, чтобы экономить время на расчёте суммы
значений $s_i$ для каждой ячейки таблицы $m$. Так как $p[i] = \sum_{k=1}^{i}s_k$,
то $\sum_{k=i+1}^{j}s_k = p[j] - p[i]$. Это позволяет вычислять каждую ячейку за
$O(n)$, что даёт время выполнения всего алгоритма $O(kn^2)$.

Для восстановления оптимального решения используется матрица $D$. В неё мы записываем
позицию разделителя, которая требовалась для получения значения $M[i,j]$. Чтобы
восстановить путь, который приёл к оптимальному решению, мы идём назад от $D[n,k]$
и добавляем разделитель в каждой указанной позиции. Эту обратную трассировку можно
выполнять с помощью рекурсивной процедуры в следующем листинге:

\begin{lstlisting}
void print(int s[], int start, int end)
{
    for (int i = start ; i <= end ; ++i)
        printf("%d ", s[i]);
    printf("\n");
}

void reconstruct(int s[], int n, int k)
{
    if (k == 1)
    {
        print(s, 1, n);
    }
    else
    {
        reconstruct(s, d[n][k], k-1);
        print(s, d[n][k] + 1, n);
    }
}
\end{lstlisting}


\section{Наилучшее расписание}

На прямой задано множество отрезков $S$. Каждому отрезку $s_i \in S$ присвоен вес $v(s_i)$.
Требуется найти максимвльное по суммарному весу подмножество попарно непересекающихся отрезков.

Предствим себе ученика, которому на выбор предложен набор факультативных занятий $S$, идущих
в определённое время. Предположим, что каждому факультативу $s_i$ можно сопоставить
его полезность (или интересность) $v(s_i)$. В таком случае хочется знать, какое подмножество
всех факультативов надо выбрать, чтобы получить максимальную пользу от их посещения.

Полный перебор всех подмножеств $S$ потребует времени $O(2^n)$, поэтому желательно найти другое
решение. Для применения динамического программирования необходимо разбить задачу на подзадачи.
Определим функцию
$$Profit(s_i) = v(s_i) + \max_{s_j \prec s_i}Profit(s_j)$$,
где запись $s_j \prec s_i$ означает, что отрезок $s_j$ лежит левее отрезка $s_i$ и они
не накладываются друг на друга. В случае, если таких отрезков нет, полагаем
$Profit(s_i) = v(s_i)$.

Таким образом, $Profit(s_i)$ --- максимальный вес подмножества непересекающихся отрезков,
которое содержит $s_i$ и, возможно, некоторые отрезки, расположенные левее.

\begin{lstlisting}
int p[N];
int f[N];
struct {int a, b, v; } seg[N];

int profit(int i)
{
    if (p[i] == 0)
    {
        int k = -1;
        int m = 0;
        for (int j = 0 ; j < N ; ++j)
            if (seg[j].b <= seg[i].a && profit(j) > m)
            {
                k = j;
                m = profit(j);
            }
        f[i] = k;
        p[i] = m + seg[i].v;
    }
    return p[i];
}
\end{lstlisting}

Если мы определим максимум функции $Profit$ по всем отрезкам, то получим ответ на исходную задачу.
В некоторых случаях больший практический интерес представляет не максимальный вес, а дающее его
множество отрезков. Для того, чтобы восстановить набор отрезков, в программу введён массив $f$,
в котором для каждого отрезка хранится предшествующий ему в оптимальном наборе.





\chapter{Задачи на деревьях}

\chapter{Динамическое программирование по профилю}

\chapter{Динамическое программирование и игры с полной информацией}

\part{Всё подряд}

\chapter{Рекуррентные соотношения}



\section{Число перестановок и факториал}

\section{Числа Стирлинга второго рода}

Числа Стирлинга второго рода --- число разбиений множества из $n$ элементов на $k$
непустых подмножеств. Обозначаются числа Стирлинга второго рода как $\stirling{n}{k}$.
Так, существует семь способор разбиения четырехэлементного множества на две части:
$$
  \{1,2,3\}\cup\{4\}, \quad \{1,2,4\}\cup\{3\}, \quad \{1,3,4\}\cup\{2\}, \quad \{2,3,4\}\cup\{1\},
  \quad \{1,2\}\cup\{3,4\}, \quad \{1,3\}\cup\{2,4\}, \quad \{1,4\}\cup\{2,3\}
$$

Следовательно, $\stirling{4}{2} = 7$.

Существует только один способ помещения $n$ элементов в одно непустое подмножество.
Следовательно, $\stirling{n}{1} = 1$ при любом $n>0$. С другой стороны, $\stirling{0}{1} = 0$,
потому что $0$-элементное множество пусто. $\stirling{0}{0} = 1$, потому что пустое множество
можно разбить на нулевое число подмножеств только одним способом. А $\stirling{n}{0} = 0$ для
$n>0$, потому что элементы множества нужно поместить хотя бы в одну часть.

Чтобы вычислить $\stirling{n}{k}$, можно использовать следующие рассуждения.
Последний объект из заданных $n$ можно поместить в отдельное подмножество. Остальные можно
разбить на множества $\stirling{n-1}{k-1}$ способами. Либо этот объект можно поместить
в одну из $k$ частей, полученных из $n-1$ объектов. Количество разбиений на такие части
будет равняться $\stirling{n-1}{k}$. Для каждого есть $k$ способов размещения последнего
элемента.
Следовательно,

$$\stirling{n}{k} = k\stirling{n-1}{k} + \stirling{n-1}{k-1}, \text{ для $n>0$}$$

\section{Числа Эйлера}

Число Эйлера $\euler{n}{k}$ --- это число перестановок $\pi_1\pi_2\ldots\pi_n$
множества $\{1,2,\ldots,n\}$, имеющих
$k$ участков подъема, а именно, $k$ мест, где $\pi_j<\pi_{j+1}$.

К примеру, одиннадцать перестановок множества $\{1,2,3,4\}$ содержат по
два участка подъема: $$1324, 1423, 2314, 2413, 3412, 1243, 1342, 2341, 2134, 3124, 4123$$.

Найдём рекуррентность для $\euler{n}{k}$. Каждая перестановка $\pi = \pi_1\pi_2\ldots\pi_{n-1}$
множества $\{1,\ldots,n-1\}$ приводит к $n$ перестановкам множества $\{1,\ldots,n\}$,
если вставлять новый элемент во все возможные места. Предположим, мы вставляем $n$ на $j$-е
место, получая $\pi' = \pi_1\ldots\pi_{j-1}n\pi_j\ldots\pi_{n-1}$. Если $j=1$ или если
$\pi_{j-1} < \pi_j$, то число участков подъема в $\pi'$ такое же, как и в $\pi$. Если же
$\pi_{j-1} > \pi_j$ или же $j=n$, то оно на единицу больше числа участков подъёма в $\pi$.
Поэтому в целом перестановка $\pi'$ с $k$ участками подъёма получается $(k+1)\euler{n-1}{k}$
способами из перестановок $\pi$, которые содержат $k$ участков подъёма, плюс
$((n-2)-(k-1)+1)\euler{n-1}{k-1}$ способами из перестановок $\pi$, которые содержат
$k-1$ участков подъёма.

Итак, искомая рекуррентность:
\begin{align*}
\euler{0}{k} &= [k = 0] \\
\euler{n}{k} &= (k+1)\euler{n-1}{k} + (n-k)\euler{n-1}{k-1}, \text{ для $n>0$} \\
\end{align*}



%\section{? Производящие функции}

%\section{? Свертки}

\chapter{Динамическое программирование}

\section{Одномерное динамическое программирование}

\section{Двумерное динамическое программирование}

\chapter{Перебор и динамическое программирование}

\chapter{Упражнения}
\begin{enumerate}

\item Решите рекуррентное соотношение
$$
\begin{array}{ll}
g_0 = 1; \\
g_n = g_{n-1} + 2g_{n-2} + \cdots + ng_0 & n>0
\end{array}
$$

\item Сколько существует способов разместить числа ${1, 2, \ldots , 2n}$ 
в виде массива размера $2 \times n$ так, чтобы и строки и столбцы массива
были упорядочены по возрастанию слева направо и сверху вниз?
Например, для $n=5$ одним из решений будет 
$$\begin{pmatrix}
1 & 2 & 4 & 5 & 8 \\
3 & 6 & 7 & 9 & 10 
\end{pmatrix}$$.

\item Число Бэлла $\varpi_n$ --- число способов разбиения множества из $n$ предметов на подмножества.
      Например, $\varpi_3=5$, поскольку множество $\{1,2,3\}$ можно разбить на такие подмножества:
      $$\{1,2,3\}; \{1,2\}\cup\{3\}; \{1,3\}\cup\{2\}; \{1\}\cup\{2,3\}; \{1\}\cup\{2\}\cup\{3\}; $$
      Найдите выражение для $\varpi_n$.

\item Если $S$ --- некоторое множество целых чисел, то пусть $S+1$ будет <<сдвинутым>>
множеством $\{x+1 \mid x \in S\}$. Сколько подмножеств множества $\{1,2,\ldots,n\}$ обладают
тем свойством, что $S\cup(S+1) = \{1,2,\ldots,n+1\}$.

\end{enumerate}

\section{Ответы}
\begin{enumerate}

\item $G(z)=(z/(1-z)^2)G(z)+1$, следовательно 
$$G(z) = \frac{1-2z+z^2}{1-3z+z^2} = 1 + \frac{z}{1-3z+z^2};$$
поэтому имеем $g_n=F_{2n}+[n=0]$.

\item $C_n$. Числа в верхнем ряду соответствуют позициям плюс единиц в последовательности
из $+1$ и $-1$, определяющей <<горную гряду>>; числа нижнего ряда отвечают позициям
минус единиц. Например, приведенный в упражнении массив соответствует
\begin{verbatim}
    /\     
 /\/  \/\  
/        \ 
\end{verbatim}.

\item $\varpi_n = \sum_k C_n^k\varpi_{n-k}$

\item $F_n$.

\end{enumerate}

\part{Задачи}

\end{document} 
